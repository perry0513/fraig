!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ARROW_DOWN_KEY	cmd/cmdCharDef.h	/^   ARROW_DOWN_KEY   = 66 + ARROW_KEY_FLAG,$/;"	e	enum:ParseChar
ARROW_DOWN_KEY	cmd/cmdCharDef.h	/^   ARROW_DOWN_KEY   = TA_ARROW_DOWN_KEY,$/;"	e	enum:ParseChar
ARROW_KEY_BEGIN	cmd/cmdCharDef.h	/^   ARROW_KEY_BEGIN  = ARROW_UP_KEY,$/;"	e	enum:ParseChar
ARROW_KEY_BEGIN	cmd/cmdCharDef.h	/^   ARROW_KEY_BEGIN  = TA_ARROW_KEY_BEGIN,$/;"	e	enum:ParseChar
ARROW_KEY_END	cmd/cmdCharDef.h	/^   ARROW_KEY_END    = ARROW_LEFT_KEY,$/;"	e	enum:ParseChar
ARROW_KEY_END	cmd/cmdCharDef.h	/^   ARROW_KEY_END    = TA_ARROW_KEY_END,$/;"	e	enum:ParseChar
ARROW_KEY_FLAG	cmd/cmdCharDef.h	/^   ARROW_KEY_FLAG   = 1 << 8,$/;"	e	enum:ParseChar
ARROW_KEY_FLAG	cmd/cmdCharDef.h	/^   ARROW_KEY_FLAG   = TA_ARROW_KEY_FLAG,$/;"	e	enum:ParseChar
ARROW_KEY_INT	cmd/cmdCharDef.h	/^   ARROW_KEY_INT    = 91,$/;"	e	enum:ParseChar
ARROW_KEY_INT	cmd/cmdCharDef.h	/^   ARROW_KEY_INT    = TA_ARROW_KEY_INT,$/;"	e	enum:ParseChar
ARROW_LEFT_KEY	cmd/cmdCharDef.h	/^   ARROW_LEFT_KEY   = 68 + ARROW_KEY_FLAG,$/;"	e	enum:ParseChar
ARROW_LEFT_KEY	cmd/cmdCharDef.h	/^   ARROW_LEFT_KEY   = TA_ARROW_LEFT_KEY,$/;"	e	enum:ParseChar
ARROW_RIGHT_KEY	cmd/cmdCharDef.h	/^   ARROW_RIGHT_KEY  = 67 + ARROW_KEY_FLAG,$/;"	e	enum:ParseChar
ARROW_RIGHT_KEY	cmd/cmdCharDef.h	/^   ARROW_RIGHT_KEY  = TA_ARROW_RIGHT_KEY,$/;"	e	enum:ParseChar
ARROW_UP_KEY	cmd/cmdCharDef.h	/^   ARROW_UP_KEY     = 65 + ARROW_KEY_FLAG,$/;"	e	enum:ParseChar
ARROW_UP_KEY	cmd/cmdCharDef.h	/^   ARROW_UP_KEY     = TA_ARROW_UP_KEY,$/;"	e	enum:ParseChar
BACK_SPACE_CHAR	cmd/cmdCharDef.h	/^   BACK_SPACE_CHAR  = 8,$/;"	e	enum:ParseChar
BACK_SPACE_CHAR	cmd/cmdCharDef.h	/^   BACK_SPACE_CHAR  = TA_BACK_SPACE_CHAR,$/;"	e	enum:ParseChar
BACK_SPACE_KEY	cmd/cmdCharDef.h	/^   BACK_SPACE_KEY   = 127,$/;"	e	enum:ParseChar
BACK_SPACE_KEY	cmd/cmdCharDef.h	/^   BACK_SPACE_KEY   = TA_BACK_SPACE_KEY,$/;"	e	enum:ParseChar
BEEP_CHAR	cmd/cmdCharDef.h	/^   BEEP_CHAR        = 7,$/;"	e	enum:ParseChar
BEEP_CHAR	cmd/cmdCharDef.h	/^   BEEP_CHAR        = TA_BEEP_CHAR,$/;"	e	enum:ParseChar
BREAK_COUNT	cir/cirSim.cpp	/^#define BREAK_COUNT /;"	d	file:
CANNOT_INVERTED	cir/cirMgr.h	/^   CANNOT_INVERTED,$/;"	e	enum:CirParseError
CIRCMDTOT	cir/cirCmd.cpp	/^   CIRCMDTOT$/;"	e	enum:CirCmdState	file:
CIRFRAIG	cir/cirCmd.cpp	/^   CIRFRAIG,$/;"	e	enum:CirCmdState	file:
CIRINIT	cir/cirCmd.cpp	/^   CIRINIT,$/;"	e	enum:CirCmdState	file:
CIROPT	cir/cirCmd.cpp	/^   CIROPT,$/;"	e	enum:CirCmdState	file:
CIRREAD	cir/cirCmd.cpp	/^   CIRREAD,$/;"	e	enum:CirCmdState	file:
CIRSIMULATE	cir/cirCmd.cpp	/^   CIRSIMULATE,$/;"	e	enum:CirCmdState	file:
CIRSTRASH	cir/cirCmd.cpp	/^   CIRSTRASH,$/;"	e	enum:CirCmdState	file:
CIR_CMD_H	cir/cirCmd.h	/^#define CIR_CMD_H$/;"	d
CIR_DEF_H	cir/cirDef.h	/^#define CIR_DEF_H$/;"	d
CIR_GATE_H	cir/cirGate.h	/^#define CIR_GATE_H$/;"	d
CIR_MGR_H	cir/cirMgr.h	/^#define CIR_MGR_H$/;"	d
CMD_CHAR_DEF_H	cmd/cmdCharDef.h	/^#define CMD_CHAR_DEF_H$/;"	d
CMD_EXEC_DONE	cmd/cmdParser.h	/^   CMD_EXEC_DONE  = 0,$/;"	e	enum:CmdExecStatus
CMD_EXEC_ERROR	cmd/cmdParser.h	/^   CMD_EXEC_ERROR = 1,$/;"	e	enum:CmdExecStatus
CMD_EXEC_NOP	cmd/cmdParser.h	/^   CMD_EXEC_NOP   = 3,$/;"	e	enum:CmdExecStatus
CMD_EXEC_QUIT	cmd/cmdParser.h	/^   CMD_EXEC_QUIT  = 2,$/;"	e	enum:CmdExecStatus
CMD_EXEC_TOT	cmd/cmdParser.h	/^   CMD_EXEC_TOT$/;"	e	enum:CmdExecStatus
CMD_OPT_ERROR_TOT	cmd/cmdParser.h	/^   CMD_OPT_ERROR_TOT$/;"	e	enum:CmdOptionError
CMD_OPT_EXTRA	cmd/cmdParser.h	/^   CMD_OPT_EXTRA      = 1,$/;"	e	enum:CmdOptionError
CMD_OPT_FOPEN_FAIL	cmd/cmdParser.h	/^   CMD_OPT_FOPEN_FAIL = 3,$/;"	e	enum:CmdOptionError
CMD_OPT_ILLEGAL	cmd/cmdParser.h	/^   CMD_OPT_ILLEGAL    = 2,$/;"	e	enum:CmdOptionError
CMD_OPT_MISSING	cmd/cmdParser.h	/^   CMD_OPT_MISSING    = 0,$/;"	e	enum:CmdOptionError
CMD_PARSER_H	cmd/cmdParser.h	/^#define CMD_PARSER_H$/;"	d
Cache	util/myHashMap.h	/^   Cache() : _size(0), _cache(0) {}$/;"	f	class:Cache
Cache	util/myHashMap.h	/^   Cache(size_t s) : _size(0), _cache(0) { init(s); }$/;"	f	class:Cache
Cache	util/myHashMap.h	/^class Cache$/;"	c
CacheNode	util/myHashMap.h	/^typedef pair<CacheKey, CacheData> CacheNode;$/;"	t	class:Cache
CirAIGGate	cir/cirGate.h	/^   CirAIGGate(int id, size_t l) :CirGate(id, l) {}$/;"	f	class:CirAIGGate
CirAIGGate	cir/cirGate.h	/^class CirAIGGate: public CirGate$/;"	c
CirCONSTGate	cir/cirGate.h	/^   CirCONSTGate(int id, size_t l) :CirGate(id, l) {}$/;"	f	class:CirCONSTGate
CirCONSTGate	cir/cirGate.h	/^class CirCONSTGate: public CirGate$/;"	c
CirCmdState	cir/cirCmd.cpp	/^enum CirCmdState$/;"	g	file:
CirFraigCmd	cir/cirCmd.h	/^CmdClass(CirFraigCmd);$/;"	v
CirGate	cir/cirGate.h	/^   CirGate(int id, size_t l)$/;"	f	class:CirGate
CirGate	cir/cirGate.h	/^class CirGate$/;"	c
CirGateCmd	cir/cirCmd.h	/^CmdClass(CirGateCmd);$/;"	v
CirMgr	cir/cirMgr.h	/^   CirMgr(): _isSimulated(false), _isFraiged(false) {}$/;"	f	class:CirMgr
CirMgr	cir/cirMgr.h	/^class CirMgr$/;"	c
CirOptCmd	cir/cirCmd.h	/^CmdClass(CirOptCmd);$/;"	v
CirPIGate	cir/cirGate.h	/^   CirPIGate(int id, size_t l) :CirGate(id, l), _sym("") {}$/;"	f	class:CirPIGate
CirPIGate	cir/cirGate.h	/^class CirPIGate: public CirGate$/;"	c
CirPOGate	cir/cirGate.h	/^   CirPOGate(int id, size_t l) :CirGate(id, l), _sym("") {}$/;"	f	class:CirPOGate
CirPOGate	cir/cirGate.h	/^class CirPOGate: public CirGate$/;"	c
CirParseError	cir/cirMgr.h	/^enum CirParseError {$/;"	g
CirPrintCmd	cir/cirCmd.h	/^CmdClass(CirPrintCmd);$/;"	v
CirReadCmd	cir/cirCmd.h	/^CmdClass(CirReadCmd);$/;"	v
CirSimCmd	cir/cirCmd.h	/^CmdClass(CirSimCmd);$/;"	v
CirStrashCmd	cir/cirCmd.h	/^CmdClass(CirStrashCmd);$/;"	v
CirSweepCmd	cir/cirCmd.h	/^CmdClass(CirSweepCmd);$/;"	v
CirUNDEFGate	cir/cirGate.h	/^   CirUNDEFGate(int id, size_t l) :CirGate(id, l) {}$/;"	f	class:CirUNDEFGate
CirUNDEFGate	cir/cirGate.h	/^class CirUNDEFGate: public CirGate$/;"	c
CirWriteCmd	cir/cirCmd.h	/^CmdClass(CirWriteCmd);$/;"	v
Clause	sat/SolverTypes.h	/^    Clause(bool learnt, const vec<Lit>& ps, ClauseId id_ = ClauseId_NULL) {$/;"	f	class:Clause
Clause	sat/SolverTypes.h	/^class Clause {$/;"	c
Clause	sat/test/SolverTypes.h	/^    Clause(bool learnt, const vec<Lit>& ps, ClauseId id_ = ClauseId_NULL) {$/;"	f	class:Clause
Clause	sat/test/SolverTypes.h	/^class Clause {$/;"	c
ClauseId	sat/SolverTypes.h	/^typedef int ClauseId;     \/\/ (might have to use uint64 one day...)$/;"	t
ClauseId	sat/test/SolverTypes.h	/^typedef int ClauseId;     \/\/ (might have to use uint64 one day...)$/;"	t
ClauseId_NULL	sat/SolverTypes.h	/^const   int ClauseId_NULL = INT_MIN;$/;"	v
ClauseId_NULL	sat/test/SolverTypes.h	/^const   int ClauseId_NULL = INT_MIN;$/;"	v
Clause_new	sat/SolverTypes.h	/^inline Clause* Clause_new(bool learnt, const vec<Lit>& ps, ClauseId id = ClauseId_NULL) {$/;"	f
Clause_new	sat/test/SolverTypes.h	/^inline Clause* Clause_new(bool learnt, const vec<Lit>& ps, ClauseId id = ClauseId_NULL) {$/;"	f
CmdClass	cmd/cmdParser.h	/^#define CmdClass(/;"	d
CmdExec	cmd/cmdParser.h	/^   CmdExec() {}$/;"	f	class:CmdExec
CmdExec	cmd/cmdParser.h	/^class CmdExec$/;"	c
CmdExecStatus	cmd/cmdParser.h	/^enum CmdExecStatus$/;"	g
CmdMap	cmd/cmdParser.h	/^typedef map<const string, CmdExec*>   CmdMap;$/;"	t	class:CmdParser
CmdOptionError	cmd/cmdParser.h	/^enum CmdOptionError$/;"	g
CmdParser	cmd/cmdParser.h	/^   CmdParser(const string& p) : _prompt(p), _dofile(0),$/;"	f	class:CmdParser
CmdParser	cmd/cmdParser.h	/^class CmdParser$/;"	c
CmdRegPair	cmd/cmdParser.h	/^typedef pair<const string, CmdExec*>  CmdRegPair;$/;"	t	class:CmdParser
DEFAULTS	sat/File.h	/^    #define DEFAULTS /;"	d
DEFAULTS	sat/File.h	/^    #undef DEFAULTS$/;"	d
DEFAULTS	sat/test/File.h	/^    #define DEFAULTS /;"	d
DEFAULTS	sat/test/File.h	/^    #undef DEFAULTS$/;"	d
DELETE_KEY	cmd/cmdCharDef.h	/^   DELETE_KEY       = 51 + MOD_KEY_FLAG,$/;"	e	enum:ParseChar
DELETE_KEY	cmd/cmdCharDef.h	/^   DELETE_KEY       = TA_DELETE_KEY,$/;"	e	enum:ParseChar
DFSFanin	cir/cirGate.cpp	/^CirGate::DFSFanin(int cl, int level, bool isNeg) const$/;"	f	class:CirGate
DFSFanout	cir/cirGate.cpp	/^CirGate::DFSFanout(int cl, int level, bool isNeg) const$/;"	f	class:CirGate
DIFFER_PERCENTAGE	cir/cirSim.cpp	/^#define DIFFER_PERCENTAGE /;"	d	file:
DUMMY_END	cir/cirMgr.h	/^   DUMMY_END$/;"	e	enum:CirParseError
Datum	sat/Global.h	/^    typedef T   Datum;$/;"	t	class:vec
Datum	sat/test/Global.h	/^    typedef T   Datum;$/;"	t	class:vec
END_KEY	cmd/cmdCharDef.h	/^   END_KEY          = 52 + MOD_KEY_FLAG,$/;"	e	enum:ParseChar
END_KEY	cmd/cmdCharDef.h	/^   END_KEY          = TA_END_KEY,$/;"	e	enum:ParseChar
ESC_KEY	cmd/cmdCharDef.h	/^   ESC_KEY          = 27,         \/\/ Not printable; used for combo keys$/;"	e	enum:ParseChar
ESC_KEY	cmd/cmdCharDef.h	/^   ESC_KEY          = TA_ESC_KEY,         \/\/ Not printable; used for combo keys$/;"	e	enum:ParseChar
EXTRA_SPACE	cir/cirMgr.h	/^   EXTRA_SPACE,$/;"	e	enum:CirParseError
Exception_EOF	sat/File.h	/^class Exception_EOF {};$/;"	c
Exception_EOF	sat/test/File.h	/^class Exception_EOF {};$/;"	c
FecCompare	cir/cirMgr.h	/^class FecCompare {$/;"	c
FecGrp	cir/cirMgr.h	/^   FecGrp () {}$/;"	f	class:FecGrp
FecGrp	cir/cirMgr.h	/^   FecGrp (unsigned d):_base(d) { _data.push_back(d); }$/;"	f	class:FecGrp
FecGrp	cir/cirMgr.h	/^class FecGrp$/;"	c
FecHash	cir/cirMgr.h	/^typedef unordered_map<unsigned, FecGrp*> FecHash;$/;"	t
File	sat/File.h	/^    File(cchar* name, cchar* mode) : DEFAULTS {$/;"	f	class:File
File	sat/File.h	/^    File(int fd, FileMode mode, bool own_fd = true) : DEFAULTS  {$/;"	f	class:File
File	sat/File.h	/^    File(void) : DEFAULTS {}$/;"	f	class:File
File	sat/File.h	/^class File {$/;"	c
File	sat/test/File.h	/^    File(cchar* name, cchar* mode) : DEFAULTS {$/;"	f	class:File
File	sat/test/File.h	/^    File(int fd, FileMode mode, bool own_fd = true) : DEFAULTS  {$/;"	f	class:File
File	sat/test/File.h	/^    File(void) : DEFAULTS {}$/;"	f	class:File
File	sat/test/File.h	/^class File {$/;"	c
FileMode	sat/File.h	/^enum FileMode { READ, WRITE };$/;"	g
FileMode	sat/test/File.h	/^enum FileMode { READ, WRITE };$/;"	g
File_BufSize	sat/File.h	/^#define File_BufSize /;"	d
File_BufSize	sat/test/File.h	/^#define File_BufSize /;"	d
File_h	sat/File.h	/^#define File_h$/;"	d
File_h	sat/test/File.h	/^#define File_h$/;"	d
GClause	sat/SolverTypes.h	/^    GClause(void* d) : data(d) {}$/;"	f	class:GClause
GClause	sat/SolverTypes.h	/^class GClause {$/;"	c
GClause	sat/test/SolverTypes.h	/^    GClause(void* d) : data(d) {}$/;"	f	class:GClause
GClause	sat/test/SolverTypes.h	/^class GClause {$/;"	c
GClause_NULL	sat/SolverTypes.h	/^#define GClause_NULL /;"	d
GClause_NULL	sat/test/SolverTypes.h	/^#define GClause_NULL /;"	d
GClause_new	sat/SolverTypes.h	/^inline GClause GClause_new(Clause* c) { assert(((uintp)c & 1) == 0); return GClause((void*)c); }$/;"	f
GClause_new	sat/SolverTypes.h	/^inline GClause GClause_new(Lit p)     { return GClause((void*)(((intp)index(p) << 1) + 1)); }$/;"	f
GClause_new	sat/test/SolverTypes.h	/^inline GClause GClause_new(Clause* c) { assert(((uintp)c & 1) == 0); return GClause((void*)c); }$/;"	f
GClause_new	sat/test/SolverTypes.h	/^inline GClause GClause_new(Lit p)     { return GClause((void*)(((intp)index(p) << 1) + 1)); }$/;"	f
Gate	sat/test/satTest.cpp	/^   Gate(unsigned i = 0): _gid(i) {}$/;"	f	class:Gate
Gate	sat/test/satTest.cpp	/^class Gate$/;"	c	file:
GateList	cir/cirDef.h	/^typedef vector<CirGate*>           GateList;$/;"	t
Global_h	sat/Global.h	/^#define Global_h$/;"	d
Global_h	sat/test/Global.h	/^#define Global_h$/;"	d
HOME_KEY	cmd/cmdCharDef.h	/^   HOME_KEY         = 49 + MOD_KEY_FLAG,$/;"	e	enum:ParseChar
HOME_KEY	cmd/cmdCharDef.h	/^   HOME_KEY         = TA_HOME_KEY,$/;"	e	enum:ParseChar
HashMap	util/myHashMap.h	/^   HashMap(size_t b=0) : _numBuckets(0), _buckets(0) { if (b != 0) init(b); }$/;"	f	class:HashMap
HashMap	util/myHashMap.h	/^class HashMap$/;"	c
HashNode	util/myHashMap.h	/^typedef pair<HashKey, HashData> HashNode;$/;"	t	class:HashMap
HashSet	util/myHashSet.h	/^   HashSet(size_t b = 0) : _numBuckets(0), _buckets(0) { if (b != 0) init(b); }$/;"	f	class:HashSet
HashSet	util/myHashSet.h	/^class HashSet$/;"	c
Heap	sat/Heap.h	/^    Heap(C c) : comp(c) { heap.push(-1); }$/;"	f	class:Heap
Heap	sat/Heap.h	/^class Heap {$/;"	c
Heap	sat/test/Heap.h	/^    Heap(C c) : comp(c) { heap.push(-1); }$/;"	f	class:Heap
Heap	sat/test/Heap.h	/^class Heap {$/;"	c
Heap_h	sat/Heap.h	/^#define Heap_h$/;"	d
Heap_h	sat/test/Heap.h	/^#define Heap_h$/;"	d
I64_fmt	sat/Global.h	/^#define I64_fmt /;"	d
I64_fmt	sat/test/Global.h	/^#define I64_fmt /;"	d
ILLEGAL_IDENTIFIER	cir/cirMgr.h	/^   ILLEGAL_IDENTIFIER,$/;"	e	enum:CirParseError
ILLEGAL_NUM	cir/cirMgr.h	/^   ILLEGAL_NUM,$/;"	e	enum:CirParseError
ILLEGAL_SYMBOL_NAME	cir/cirMgr.h	/^   ILLEGAL_SYMBOL_NAME,$/;"	e	enum:CirParseError
ILLEGAL_SYMBOL_TYPE	cir/cirMgr.h	/^   ILLEGAL_SYMBOL_TYPE,$/;"	e	enum:CirParseError
ILLEGAL_WSPACE	cir/cirMgr.h	/^   ILLEGAL_WSPACE,$/;"	e	enum:CirParseError
INPUT_END_KEY	cmd/cmdCharDef.h	/^   INPUT_END_KEY    = 4,          \/\/ ctrl-d$/;"	e	enum:ParseChar
INPUT_END_KEY	cmd/cmdCharDef.h	/^   INPUT_END_KEY    = TA_INPUT_END_KEY,   \/\/ ctrl-d$/;"	e	enum:ParseChar
INSERT_KEY	cmd/cmdCharDef.h	/^   INSERT_KEY       = 50 + MOD_KEY_FLAG,$/;"	e	enum:ParseChar
INSERT_KEY	cmd/cmdCharDef.h	/^   INSERT_KEY       = TA_INSERT_KEY,$/;"	e	enum:ParseChar
INTERVAL	cir/cirSim.cpp	/^#define INTERVAL /;"	d	file:
INV	cir/cirDef.h	/^   #define INV /;"	d
IdList	cir/cirDef.h	/^typedef vector<unsigned>           IdList;$/;"	t
Key	sat/Global.h	/^    typedef int Key;$/;"	t	class:vec
Key	sat/test/Global.h	/^    typedef int Key;$/;"	t	class:vec
LINE_BEGIN_KEY	cmd/cmdCharDef.h	/^   LINE_BEGIN_KEY   = 1,          \/\/ ctrl-a$/;"	e	enum:ParseChar
LINE_BEGIN_KEY	cmd/cmdCharDef.h	/^   LINE_BEGIN_KEY   = TA_LINE_BEGIN_KEY,  \/\/ ctrl-a$/;"	e	enum:ParseChar
LINE_END_KEY	cmd/cmdCharDef.h	/^   LINE_END_KEY     = 5,          \/\/ ctrl-e$/;"	e	enum:ParseChar
LINE_END_KEY	cmd/cmdCharDef.h	/^   LINE_END_KEY     = TA_LINE_END_KEY,    \/\/ ctrl-e$/;"	e	enum:ParseChar
LOG_DEBUG	cir/cirDef.h	/^#define LOG_DEBUG$/;"	d
L_LIT	sat/Solver.h	/^#define L_LIT /;"	d
L_LIT	sat/test/Solver.h	/^#define L_LIT /;"	d
L_lit	sat/Solver.h	/^#define L_lit(/;"	d
L_lit	sat/test/Solver.h	/^#define L_lit(/;"	d
LessThan_default	sat/Sort.h	/^struct LessThan_default {$/;"	s
LessThan_default	sat/test/Sort.h	/^struct LessThan_default {$/;"	s
Lit	sat/SolverTypes.h	/^    Lit() : x(2*var_Undef) {}   \/\/ (lit_Undef)$/;"	f	class:Lit
Lit	sat/SolverTypes.h	/^    explicit Lit(Var var, bool sgn = false) : x((var+var) + (int)sgn) {}$/;"	f	class:Lit
Lit	sat/SolverTypes.h	/^class Lit {$/;"	c
Lit	sat/test/SolverTypes.h	/^    Lit() : x(2*var_Undef) {}   \/\/ (lit_Undef)$/;"	f	class:Lit
Lit	sat/test/SolverTypes.h	/^    explicit Lit(Var var, bool sgn = false) : x((var+var) + (int)sgn) {}$/;"	f	class:Lit
Lit	sat/test/SolverTypes.h	/^class Lit {$/;"	c
MAX_LIT_ID	cir/cirMgr.h	/^   MAX_LIT_ID,$/;"	e	enum:CirParseError
MISSING_DEF	cir/cirMgr.h	/^   MISSING_DEF,$/;"	e	enum:CirParseError
MISSING_IDENTIFIER	cir/cirMgr.h	/^   MISSING_IDENTIFIER,$/;"	e	enum:CirParseError
MISSING_NEWLINE	cir/cirMgr.h	/^   MISSING_NEWLINE,$/;"	e	enum:CirParseError
MISSING_NUM	cir/cirMgr.h	/^   MISSING_NUM,$/;"	e	enum:CirParseError
MISSING_SPACE	cir/cirMgr.h	/^   MISSING_SPACE,$/;"	e	enum:CirParseError
MOD_KEY_BEGIN	cmd/cmdCharDef.h	/^   MOD_KEY_BEGIN    = HOME_KEY,$/;"	e	enum:ParseChar
MOD_KEY_BEGIN	cmd/cmdCharDef.h	/^   MOD_KEY_BEGIN    = TA_MOD_KEY_BEGIN,$/;"	e	enum:ParseChar
MOD_KEY_DUMMY	cmd/cmdCharDef.h	/^   MOD_KEY_DUMMY    = 126,$/;"	e	enum:ParseChar
MOD_KEY_DUMMY	cmd/cmdCharDef.h	/^   MOD_KEY_DUMMY    = TA_MOD_KEY_DUMMY,$/;"	e	enum:ParseChar
MOD_KEY_END	cmd/cmdCharDef.h	/^   MOD_KEY_END      = PG_DOWN_KEY,$/;"	e	enum:ParseChar
MOD_KEY_END	cmd/cmdCharDef.h	/^   MOD_KEY_END      = TA_MOD_KEY_END,$/;"	e	enum:ParseChar
MOD_KEY_FLAG	cmd/cmdCharDef.h	/^   MOD_KEY_FLAG     = 1 << 9,$/;"	e	enum:ParseChar
MOD_KEY_FLAG	cmd/cmdCharDef.h	/^   MOD_KEY_FLAG     = TA_MOD_KEY_FLAG,$/;"	e	enum:ParseChar
MOD_KEY_INT	cmd/cmdCharDef.h	/^   MOD_KEY_INT      = 91,$/;"	e	enum:ParseChar
MOD_KEY_INT	cmd/cmdCharDef.h	/^   MOD_KEY_INT      = TA_MOD_KEY_INT,$/;"	e	enum:ParseChar
MYCLK_TCK	util/myUsage.h	/^#define MYCLK_TCK /;"	d
MYCLK_TCK	util/myUsage.h	/^#undef MYCLK_TCK$/;"	d
MY_HASH_MAP_H	util/myHashMap.h	/^#define MY_HASH_MAP_H$/;"	d
MY_HASH_SET_H	util/myHashSet.h	/^#define MY_HASH_SET_H$/;"	d
MY_USAGE_H	util/myUsage.h	/^#define MY_USAGE_H$/;"	d
MyUsage	util/myUsage.h	/^   MyUsage() { reset(); }$/;"	f	class:MyUsage
MyUsage	util/myUsage.h	/^class MyUsage$/;"	c
NEWLINE_KEY	cmd/cmdCharDef.h	/^   NEWLINE_KEY      = TA_NEWLINE_KEY,     \/\/ enter('\\n') or ctrl-m$/;"	e	enum:ParseChar
NEWLINE_KEY	cmd/cmdCharDef.h	/^   NEWLINE_KEY      = int('\\n'),  \/\/ enter('\\n') or ctrl-m$/;"	e	enum:ParseChar
NUM_TOO_BIG	cir/cirMgr.h	/^   NUM_TOO_BIG,$/;"	e	enum:CirParseError
NUM_TOO_SMALL	cir/cirMgr.h	/^   NUM_TOO_SMALL,$/;"	e	enum:CirParseError
PARSE_CHAR_END	cmd/cmdCharDef.h	/^   PARSE_CHAR_END$/;"	e	enum:ParseChar
PG_DOWN_KEY	cmd/cmdCharDef.h	/^   PG_DOWN_KEY      = 54 + MOD_KEY_FLAG,$/;"	e	enum:ParseChar
PG_DOWN_KEY	cmd/cmdCharDef.h	/^   PG_DOWN_KEY      = TA_PG_DOWN_KEY,$/;"	e	enum:ParseChar
PG_OFFSET	cmd/cmdParser.h	/^#define PG_OFFSET /;"	d
PG_UP_KEY	cmd/cmdCharDef.h	/^   PG_UP_KEY        = 53 + MOD_KEY_FLAG,$/;"	e	enum:ParseChar
PG_UP_KEY	cmd/cmdCharDef.h	/^   PG_UP_KEY        = TA_PG_UP_KEY,$/;"	e	enum:ParseChar
ParseChar	cmd/cmdCharDef.h	/^enum ParseChar$/;"	g
Proof	sat/Proof.cpp	/^Proof::Proof()$/;"	f	class:Proof
Proof	sat/Proof.cpp	/^Proof::Proof(ProofTraverser& t)$/;"	f	class:Proof
Proof	sat/Proof.h	/^class Proof {$/;"	c
Proof	sat/test/Proof.cpp	/^Proof::Proof()$/;"	f	class:Proof
Proof	sat/test/Proof.cpp	/^Proof::Proof(ProofTraverser& t)$/;"	f	class:Proof
Proof	sat/test/Proof.h	/^class Proof {$/;"	c
ProofTraverser	sat/Proof.h	/^struct ProofTraverser {$/;"	s
ProofTraverser	sat/test/Proof.h	/^struct ProofTraverser {$/;"	s
Proof_h	sat/Proof.h	/^#define Proof_h$/;"	d
Proof_h	sat/test/Proof.h	/^#define Proof_h$/;"	d
READ	sat/File.h	/^enum FileMode { READ, WRITE };$/;"	e	enum:FileMode
READ	sat/test/File.h	/^enum FileMode { READ, WRITE };$/;"	e	enum:FileMode
READ_BUF_SIZE	cmd/cmdParser.h	/^#define READ_BUF_SIZE /;"	d
REDEF_CONST	cir/cirMgr.h	/^   REDEF_CONST,$/;"	e	enum:CirParseError
REDEF_GATE	cir/cirMgr.h	/^   REDEF_GATE,$/;"	e	enum:CirParseError
REDEF_SYMBOLIC_NAME	cir/cirMgr.h	/^   REDEF_SYMBOLIC_NAME,$/;"	e	enum:CirParseError
RN_GEN_H	util/rnGen.h	/^#define RN_GEN_H$/;"	d
RandomNumGen	util/rnGen.h	/^      RandomNumGen() { my_srandom(getpid()); }$/;"	f	class:RandomNumGen
RandomNumGen	util/rnGen.h	/^      RandomNumGen(unsigned seed) { my_srandom(seed); }$/;"	f	class:RandomNumGen
RandomNumGen	util/rnGen.h	/^class RandomNumGen$/;"	c
SAT_H	sat/sat.h	/^#define SAT_H$/;"	d
SAT_H	sat/test/sat.h	/^#define SAT_H$/;"	d
STATIC_ASSERTION_FAILURE	sat/Global.h	/^template <bool> struct STATIC_ASSERTION_FAILURE {};$/;"	s
STATIC_ASSERTION_FAILURE	sat/test/Global.h	/^template <bool> struct STATIC_ASSERTION_FAILURE {};$/;"	s
SatSolver	sat/sat.h	/^      SatSolver():_solver(0) { }$/;"	f	class:SatSolver
SatSolver	sat/sat.h	/^class SatSolver$/;"	c
SatSolver	sat/test/sat.h	/^      SatSolver():_solver(0) { }$/;"	f	class:SatSolver
SatSolver	sat/test/sat.h	/^class SatSolver$/;"	c
SearchParams	sat/Solver.h	/^    SearchParams(double v = 1, double c = 1, double r = 0) : var_decay(v), clause_decay(c), random_var_freq(r) { }$/;"	f	struct:SearchParams
SearchParams	sat/Solver.h	/^struct SearchParams {$/;"	s
SearchParams	sat/test/Solver.h	/^    SearchParams(double v = 1, double c = 1, double r = 0) : var_decay(v), clause_decay(c), random_var_freq(r) { }$/;"	f	struct:SearchParams
SearchParams	sat/test/Solver.h	/^struct SearchParams {$/;"	s
SimHash	cir/cirMgr.h	/^typedef unordered_map<SimValue, FecGrp*, SimHasher> SimHash;$/;"	t
SimHasher	cir/cirDef.h	/^struct SimHasher$/;"	s
SimValue	cir/cirDef.h	/^   SimValue(size_t v = 0): _v(v) {}$/;"	f	class:SimValue
SimValue	cir/cirDef.h	/^class SimValue$/;"	c
Solver	sat/Solver.h	/^    Solver() : ok               (true)$/;"	f	class:Solver
Solver	sat/Solver.h	/^class Solver {$/;"	c
Solver	sat/test/Solver.h	/^    Solver() : ok               (true)$/;"	f	class:Solver
Solver	sat/test/Solver.h	/^class Solver {$/;"	c
SolverStats	sat/Solver.h	/^    SolverStats() : starts(0), decisions(0), propagations(0), conflicts(0)$/;"	f	struct:SolverStats
SolverStats	sat/Solver.h	/^struct SolverStats {$/;"	s
SolverStats	sat/test/Solver.h	/^    SolverStats() : starts(0), decisions(0), propagations(0), conflicts(0)$/;"	f	struct:SolverStats
SolverStats	sat/test/Solver.h	/^struct SolverStats {$/;"	s
SolverTypes_h	sat/SolverTypes.h	/^#define SolverTypes_h$/;"	d
SolverTypes_h	sat/test/SolverTypes.h	/^#define SolverTypes_h$/;"	d
Solver_h	sat/Solver.h	/^#define Solver_h$/;"	d
Solver_h	sat/test/Solver.h	/^#define Solver_h$/;"	d
Sort_h	sat/Sort.h	/^#define Sort_h$/;"	d
Sort_h	sat/test/Sort.h	/^#define Sort_h$/;"	d
TAB_KEY	cmd/cmdCharDef.h	/^   TAB_KEY          = TA_TAB_KEY,         \/\/ tab('\\t') or Ctrl-i$/;"	e	enum:ParseChar
TAB_KEY	cmd/cmdCharDef.h	/^   TAB_KEY          = int('\\t'),  \/\/ tab('\\t') or Ctrl-i$/;"	e	enum:ParseChar
TA_ARROW_DOWN_KEY	cmd/cmdCharDef.h	/^#define TA_ARROW_DOWN_KEY /;"	d
TA_ARROW_KEY_BEGIN	cmd/cmdCharDef.h	/^#define TA_ARROW_KEY_BEGIN /;"	d
TA_ARROW_KEY_END	cmd/cmdCharDef.h	/^#define TA_ARROW_KEY_END /;"	d
TA_ARROW_KEY_FLAG	cmd/cmdCharDef.h	/^#define TA_ARROW_KEY_FLAG /;"	d
TA_ARROW_KEY_INT	cmd/cmdCharDef.h	/^#define TA_ARROW_KEY_INT /;"	d
TA_ARROW_LEFT_KEY	cmd/cmdCharDef.h	/^#define TA_ARROW_LEFT_KEY /;"	d
TA_ARROW_RIGHT_KEY	cmd/cmdCharDef.h	/^#define TA_ARROW_RIGHT_KEY /;"	d
TA_ARROW_UP_KEY	cmd/cmdCharDef.h	/^#define TA_ARROW_UP_KEY /;"	d
TA_BACK_SPACE_CHAR	cmd/cmdCharDef.h	/^#define TA_BACK_SPACE_CHAR /;"	d
TA_BACK_SPACE_KEY	cmd/cmdCharDef.h	/^#define TA_BACK_SPACE_KEY /;"	d
TA_BEEP_CHAR	cmd/cmdCharDef.h	/^#define TA_BEEP_CHAR /;"	d
TA_DELETE_KEY	cmd/cmdCharDef.h	/^#define TA_DELETE_KEY /;"	d
TA_END_KEY	cmd/cmdCharDef.h	/^#define TA_END_KEY /;"	d
TA_ESC_KEY	cmd/cmdCharDef.h	/^#define TA_ESC_KEY /;"	d
TA_HOME_KEY	cmd/cmdCharDef.h	/^#define TA_HOME_KEY /;"	d
TA_INPUT_END_KEY	cmd/cmdCharDef.h	/^#define TA_INPUT_END_KEY /;"	d
TA_INSERT_KEY	cmd/cmdCharDef.h	/^#define TA_INSERT_KEY /;"	d
TA_LINE_BEGIN_KEY	cmd/cmdCharDef.h	/^#define TA_LINE_BEGIN_KEY /;"	d
TA_LINE_END_KEY	cmd/cmdCharDef.h	/^#define TA_LINE_END_KEY /;"	d
TA_MOD_KEY_BEGIN	cmd/cmdCharDef.h	/^#define TA_MOD_KEY_BEGIN /;"	d
TA_MOD_KEY_DUMMY	cmd/cmdCharDef.h	/^#define TA_MOD_KEY_DUMMY /;"	d
TA_MOD_KEY_END	cmd/cmdCharDef.h	/^#define TA_MOD_KEY_END /;"	d
TA_MOD_KEY_FLAG	cmd/cmdCharDef.h	/^#define TA_MOD_KEY_FLAG /;"	d
TA_MOD_KEY_INT	cmd/cmdCharDef.h	/^#define TA_MOD_KEY_INT /;"	d
TA_NEWLINE_KEY	cmd/cmdCharDef.h	/^#define TA_NEWLINE_KEY /;"	d
TA_PG_DOWN_KEY	cmd/cmdCharDef.h	/^#define TA_PG_DOWN_KEY /;"	d
TA_PG_UP_KEY	cmd/cmdCharDef.h	/^#define TA_PG_UP_KEY /;"	d
TA_TAB_KEY	cmd/cmdCharDef.h	/^#define TA_TAB_KEY /;"	d
TA_UNDEFINED_KEY	cmd/cmdCharDef.h	/^#define TA_UNDEFINED_KEY /;"	d
TEMPLATE_FAIL	sat/Global.h	/^#define TEMPLATE_FAIL /;"	d
TEMPLATE_FAIL	sat/test/Global.h	/^#define TEMPLATE_FAIL /;"	d
TRA_INT	sat/Proof.h	/^    int             TRA_INT;$/;"	m	class:Proof
TRA_INT	sat/test/Proof.h	/^    int             TRA_INT;$/;"	m	class:Proof
TempFiles	sat/Proof.cpp	/^class TempFiles {$/;"	c	file:
TempFiles	sat/test/Proof.cpp	/^class TempFiles {$/;"	c	file:
UNDEFINED_KEY	cmd/cmdCharDef.h	/^   UNDEFINED_KEY    = TA_UNDEFINED_KEY,$/;"	e	enum:ParseChar
UNDEFINED_KEY	cmd/cmdCharDef.h	/^   UNDEFINED_KEY  = INT_MAX,$/;"	e	enum:ParseChar
UTIL_H	util/util.h	/^#define UTIL_H$/;"	d
Var	sat/SolverTypes.h	/^typedef int Var;$/;"	t
Var	sat/test/SolverTypes.h	/^typedef int Var;$/;"	t
VarOrder	sat/VarOrder.h	/^    VarOrder(const vec<char>& ass, const vec<double>& act) :$/;"	f	class:VarOrder
VarOrder	sat/VarOrder.h	/^class VarOrder {$/;"	c
VarOrder	sat/test/VarOrder.h	/^    VarOrder(const vec<char>& ass, const vec<double>& act) :$/;"	f	class:VarOrder
VarOrder	sat/test/VarOrder.h	/^class VarOrder {$/;"	c
VarOrder_h	sat/VarOrder.h	/^#define VarOrder_h$/;"	d
VarOrder_h	sat/test/VarOrder.h	/^#define VarOrder_h$/;"	d
VarOrder_lt	sat/VarOrder.h	/^    VarOrder_lt(const vec<double>&  act) : activity(act) { }$/;"	f	struct:VarOrder_lt
VarOrder_lt	sat/VarOrder.h	/^struct VarOrder_lt {$/;"	s
VarOrder_lt	sat/test/VarOrder.h	/^    VarOrder_lt(const vec<double>&  act) : activity(act) { }$/;"	f	struct:VarOrder_lt
VarOrder_lt	sat/test/VarOrder.h	/^struct VarOrder_lt {$/;"	s
WRITE	sat/File.h	/^enum FileMode { READ, WRITE };$/;"	e	enum:FileMode
WRITE	sat/test/File.h	/^enum FileMode { READ, WRITE };$/;"	e	enum:FileMode
_A	cir/cirMgr.h	/^   size_t          _A;$/;"	m	class:CirMgr
_DFSList	cir/cirMgr.h	/^   IdList          _DFSList;           \/\/ stored in gateId$/;"	m	class:CirMgr
_M	cir/cirMgr.h	/^   size_t          _M;$/;"	m	class:CirMgr
_PIList	cir/cirMgr.h	/^   IdList          _PIList;            \/\/ stored in pos\/neg$/;"	m	class:CirMgr
_POList	cir/cirMgr.h	/^   IdList          _POList;            \/\/ stored in pos\/neg$/;"	m	class:CirMgr
__SGI_STL_INTERNAL_RELOPS	sat/Global.h	/^#define __SGI_STL_INTERNAL_RELOPS$/;"	d
__SGI_STL_INTERNAL_RELOPS	sat/test/Global.h	/^#define __SGI_STL_INTERNAL_RELOPS$/;"	d
_assump	sat/sat.h	/^      vec<Lit>          _assump;    \/\/ Assumption List for assumption solve$/;"	m	class:SatSolver
_assump	sat/test/sat.h	/^      vec<Lit>          _assump;    \/\/ Assumption List for assumption solve$/;"	m	class:SatSolver
_base	cir/cirMgr.h	/^   unsigned _base;$/;"	m	class:FecGrp
_buckets	util/myHashMap.h	/^      vector<HashNode>*    _buckets;$/;"	m	class:HashMap::iterator
_buckets	util/myHashMap.h	/^   vector<HashNode>*        _buckets;$/;"	m	class:HashMap
_buckets	util/myHashSet.h	/^      vector<Data>*  _buckets;$/;"	m	class:HashSet::iterator
_buckets	util/myHashSet.h	/^   vector<Data>*     _buckets;$/;"	m	class:HashSet
_cB	util/myHashMap.h	/^      size_t               _cB;$/;"	m	class:HashMap::iterator
_cB	util/myHashSet.h	/^      size_t         _cB;$/;"	m	class:HashSet::iterator
_cache	util/myHashMap.h	/^   CacheNode*     _cache;$/;"	m	class:Cache
_cmdMap	cmd/cmdParser.h	/^   CmdMap    _cmdMap;                \/\/ map from string to command$/;"	m	class:CmdParser
_curVar	sat/sat.h	/^      Var               _curVar;    \/\/ Variable currently$/;"	m	class:SatSolver
_curVar	sat/test/sat.h	/^      Var               _curVar;    \/\/ Variable currently$/;"	m	class:SatSolver
_currentMem	util/myUsage.h	/^   double     _currentMem;$/;"	m	class:MyUsage
_currentTick	util/myUsage.h	/^   double     _currentTick;$/;"	m	class:MyUsage
_data	cir/cirMgr.h	/^   IdList   _data;$/;"	m	class:FecGrp
_dofile	cmd/cmdParser.h	/^   ifstream* _dofile;                \/\/ for command script$/;"	m	class:CmdParser
_dofileStack	cmd/cmdParser.h	/^   stack<ifstream*> _dofileStack;    \/\/ For recursive dofile calling$/;"	m	class:CmdParser
_faninList	cir/cirGate.h	/^   IdList           _faninList;$/;"	m	class:CirGate
_fanoutList	cir/cirGate.h	/^   IdList           _fanoutList;$/;"	m	class:CirGate
_fecFriends	cir/cirMgr.h	/^   FecHash          _fecFriends;$/;"	m	class:CirMgr
_fecGrps	cir/cirMgr.h	/^   vector<FecGrp*> _fecGrps;$/;"	m	class:CirMgr
_floatFaninList	cir/cirMgr.h	/^   IdList          _floatFaninList;    \/\/ stored in gateId$/;"	m	class:CirMgr
_gateList	cir/cirMgr.h	/^   GateList        _gateList;$/;"	m	class:CirMgr
_gid	cir/cirGate.h	/^   int              _gid;$/;"	m	class:CirGate
_gid	sat/test/satTest.cpp	/^   unsigned   _gid;  \/\/ for debugging purpose...$/;"	m	class:Gate	file:
_globalRef	cir/cirGate.cpp	/^size_t CirGate::_globalRef = 1;$/;"	m	class:CirGate	file:
_globalRef	cir/cirGate.h	/^   static size_t    _globalRef;$/;"	m	class:CirGate
_history	cmd/cmdParser.h	/^   vector<string>   _history;        \/\/ oldest:_history[0],latest:_hist.back()$/;"	m	class:CmdParser
_historyIdx	cmd/cmdParser.h	/^   int       _historyIdx;            \/\/ (1) Position to insert history string$/;"	m	class:CmdParser
_initMem	util/myUsage.h	/^   double     _initMem;$/;"	m	class:MyUsage
_inputs	cir/cirMgr.h	/^   vector<size_t>  _inputs;$/;"	m	class:CirMgr
_isFraiged	cir/cirMgr.h	/^   bool            _isFraiged;$/;"	m	class:CirMgr
_isSimulated	cir/cirMgr.h	/^   bool            _isSimulated;$/;"	m	class:CirMgr
_it	util/myHashMap.h	/^      typename vector<HashNode>::iterator _it;$/;"	m	class:HashMap::iterator
_it	util/myHashSet.h	/^      typename vector<Data>::iterator _it;$/;"	m	class:HashSet::iterator
_mgr	cir/cirGate.cpp	/^CirMgr* CirGate::_mgr = cirMgr;$/;"	m	class:CirGate	file:
_mgr	cir/cirGate.h	/^   static CirMgr*   _mgr;$/;"	m	class:CirGate
_mgr	cir/cirMgr.cpp	/^CirMgr* FecGrp::_mgr = cirMgr;$/;"	m	class:FecGrp	file:
_mgr	cir/cirMgr.h	/^   static CirMgr* _mgr;$/;"	m	class:FecGrp
_numBuckets	util/myHashMap.h	/^      size_t               _numBuckets;$/;"	m	class:HashMap::iterator
_numBuckets	util/myHashMap.h	/^   size_t                   _numBuckets;$/;"	m	class:HashMap
_numBuckets	util/myHashSet.h	/^      size_t         _numBuckets;$/;"	m	class:HashSet::iterator
_numBuckets	util/myHashSet.h	/^   size_t            _numBuckets;$/;"	m	class:HashSet
_optCmd	cmd/cmdParser.h	/^   string            _optCmd;$/;"	m	class:CmdExec
_outputs	cir/cirMgr.h	/^   vector<size_t>  _outputs;$/;"	m	class:CirMgr
_periodUsedTime	util/myUsage.h	/^   double     _periodUsedTime;$/;"	m	class:MyUsage
_pos	cir/cirGate.h	/^   unsigned         _pos;$/;"	m	class:CirGate
_prompt	cmd/cmdParser.h	/^   const string _prompt;             \/\/ command prompt$/;"	m	class:CmdParser
_readBuf	cmd/cmdParser.h	/^   char      _readBuf[READ_BUF_SIZE];\/\/ save the current line input$/;"	m	class:CmdParser
_readBufEnd	cmd/cmdParser.h	/^   char*     _readBufEnd;            \/\/ end of string position of _readBuf$/;"	m	class:CmdParser
_readBufPtr	cmd/cmdParser.h	/^   char*     _readBufPtr;            \/\/ point to the cursor position$/;"	m	class:CmdParser
_ref	cir/cirGate.h	/^   mutable size_t   _ref;$/;"	m	class:CirGate
_simLog	cir/cirMgr.h	/^   ofstream*       _simLog;$/;"	m	class:CirMgr
_size	util/myHashMap.h	/^   size_t         _size;$/;"	m	class:Cache
_solver	sat/sat.h	/^      Solver           *_solver;    \/\/ Pointer to a Minisat solver$/;"	m	class:SatSolver
_solver	sat/test/sat.h	/^      Solver           *_solver;    \/\/ Pointer to a Minisat solver$/;"	m	class:SatSolver
_sym	cir/cirGate.h	/^   string     _sym;$/;"	m	class:CirPIGate
_sym	cir/cirGate.h	/^   string     _sym;$/;"	m	class:CirPOGate
_tabPressCount	cmd/cmdParser.h	/^   size_t    _tabPressCount;         \/\/ The number of tab pressed$/;"	m	class:CmdParser
_tempCmdStored	cmd/cmdParser.h	/^   bool      _tempCmdStored;         \/\/ When up\/pgUp is pressed, current line$/;"	m	class:CmdParser
_totalUsedTime	util/myUsage.h	/^   double     _totalUsedTime;$/;"	m	class:MyUsage
_unusedList	cir/cirMgr.h	/^   IdList          _unusedList;        \/\/ stored in gateId$/;"	m	class:CirMgr
_v	cir/cirDef.h	/^   size_t _v;$/;"	m	class:SimValue
_val	cir/cirGate.h	/^   SimValue         _val;$/;"	m	class:CirGate
_var	cir/cirGate.h	/^   Var        _var;$/;"	m	class:CirAIGGate
_var	cir/cirGate.h	/^   Var        _var;$/;"	m	class:CirCONSTGate
_var	cir/cirGate.h	/^   Var        _var;$/;"	m	class:CirPIGate
_var	cir/cirGate.h	/^   Var        _var;$/;"	m	class:CirUNDEFGate
_var	sat/test/satTest.cpp	/^   Var        _var;$/;"	m	class:Gate	file:
activity	sat/Solver.h	/^    vec<double>         activity;         \/\/ A heuristic measurement of the activity of a variable.$/;"	m	class:Solver
activity	sat/SolverTypes.h	/^    float&    activity    ()      const {$/;"	f	class:Clause
activity	sat/VarOrder.h	/^    const vec<double>&  activity;$/;"	m	struct:VarOrder_lt
activity	sat/test/Solver.h	/^    vec<double>         activity;         \/\/ A heuristic measurement of the activity of a variable.$/;"	m	class:Solver
activity	sat/test/SolverTypes.h	/^    float&    activity    ()      const {$/;"	f	class:Clause
activity	sat/test/VarOrder.h	/^    const vec<double>&  activity;$/;"	m	struct:VarOrder_lt
add	cir/cirMgr.h	/^   void add(unsigned d) { _data.push_back(d); }$/;"	f	class:FecGrp
addAigCNF	sat/sat.h	/^      void addAigCNF(Var vf, Var va, bool fa, Var vb, bool fb) {$/;"	f	class:SatSolver
addAigCNF	sat/test/sat.h	/^      void addAigCNF(Var vf, Var va, bool fa, Var vb, bool fb) {$/;"	f	class:SatSolver
addBinary	sat/Solver.h	/^    void    addBinary (Lit p, Lit q)        { addBinary_tmp [0] = p; addBinary_tmp [1] = q; addClause(addBinary_tmp); }$/;"	f	class:Solver
addBinary	sat/test/Solver.h	/^    void    addBinary (Lit p, Lit q)        { addBinary_tmp [0] = p; addBinary_tmp [1] = q; addClause(addBinary_tmp); }$/;"	f	class:Solver
addBinary_tmp	sat/Solver.h	/^    vec<Lit>            addBinary_tmp;$/;"	m	class:Solver
addBinary_tmp	sat/test/Solver.h	/^    vec<Lit>            addBinary_tmp;$/;"	m	class:Solver
addClause	sat/Solver.h	/^    void    addClause (const vec<Lit>& ps , bool A = true)  { newClause(ps , false , ClauseId_NULL , A); }  $/;"	f	class:Solver
addClause	sat/test/Solver.h	/^    void    addClause (const vec<Lit>& ps , bool A = true)  { newClause(ps , false , ClauseId_NULL , A); }  $/;"	f	class:Solver
addFanin	cir/cirGate.h	/^   void addFanin(size_t d) { _faninList.push_back(d); }$/;"	f	class:CirGate
addFanout	cir/cirGate.h	/^   void addFanout(size_t d) { _fanoutList.push_back(d); }$/;"	f	class:CirGate
addNewGrps	cir/cirSim.cpp	/^CirMgr::addNewGrps()$/;"	f	class:CirMgr
addRoot	sat/Proof.cpp	/^ClauseId Proof::addRoot(vec<Lit>& cl, bool A)$/;"	f	class:Proof
addRoot	sat/test/Proof.cpp	/^ClauseId Proof::addRoot(vec<Lit>& cl, bool A)$/;"	f	class:Proof
addTernary	sat/Solver.h	/^    void    addTernary(Lit p, Lit q, Lit r) { addTernary_tmp[0] = p; addTernary_tmp[1] = q; addTernary_tmp[2] = r; addClause(addTernary_tmp); }$/;"	f	class:Solver
addTernary	sat/test/Solver.h	/^    void    addTernary(Lit p, Lit q, Lit r) { addTernary_tmp[0] = p; addTernary_tmp[1] = q; addTernary_tmp[2] = r; addClause(addTernary_tmp); }$/;"	f	class:Solver
addTernary_tmp	sat/Solver.h	/^    vec<Lit>            addTernary_tmp;$/;"	m	class:Solver
addTernary_tmp	sat/test/Solver.h	/^    vec<Lit>            addTernary_tmp;$/;"	m	class:Solver
addUnit	sat/Solver.h	/^    void    addUnit   (Lit p)               { addUnit_tmp   [0] = p; addClause(addUnit_tmp); }$/;"	f	class:Solver
addUnit	sat/test/Solver.h	/^    void    addUnit   (Lit p)               { addUnit_tmp   [0] = p; addClause(addUnit_tmp); }$/;"	f	class:Solver
addUnit_tmp	sat/Solver.h	/^    vec<Lit>            addUnit_tmp;$/;"	m	class:Solver
addUnit_tmp	sat/test/Solver.h	/^    vec<Lit>            addUnit_tmp;$/;"	m	class:Solver
addXorCNF	sat/sat.h	/^      void addXorCNF(Var vf, Var va, bool fa, Var vb, bool fb) {$/;"	f	class:SatSolver
addXorCNF	sat/test/sat.h	/^      void addXorCNF(Var vf, Var va, bool fa, Var vb, bool fb) {$/;"	f	class:SatSolver
analyze	sat/Solver.cpp	/^void Solver::analyze(Clause* confl, vec<Lit>& out_learnt, int& out_btlevel)$/;"	f	class:Solver
analyze	sat/test/Solver.cpp	/^void Solver::analyze(Clause* confl, vec<Lit>& out_learnt, int& out_btlevel)$/;"	f	class:Solver
analyzeFinal	sat/Solver.cpp	/^void Solver::analyzeFinal(Clause* confl, bool skip_first)$/;"	f	class:Solver
analyzeFinal	sat/test/Solver.cpp	/^void Solver::analyzeFinal(Clause* confl, bool skip_first)$/;"	f	class:Solver
analyze_removable	sat/Solver.cpp	/^bool Solver::analyze_removable(Lit p, uint min_level)$/;"	f	class:Solver
analyze_removable	sat/test/Solver.cpp	/^bool Solver::analyze_removable(Lit p, uint min_level)$/;"	f	class:Solver
analyze_seen	sat/Solver.h	/^    vec<char>           analyze_seen;$/;"	m	class:Solver
analyze_seen	sat/test/Solver.h	/^    vec<char>           analyze_seen;$/;"	m	class:Solver
analyze_stack	sat/Solver.h	/^    vec<Lit>            analyze_stack;$/;"	m	class:Solver
analyze_stack	sat/test/Solver.h	/^    vec<Lit>            analyze_stack;$/;"	m	class:Solver
analyze_tmpbin	sat/Solver.h	/^    Clause*             analyze_tmpbin;$/;"	m	class:Solver
analyze_tmpbin	sat/test/Solver.h	/^    Clause*             analyze_tmpbin;$/;"	m	class:Solver
analyze_toclear	sat/Solver.h	/^    vec<Lit>            analyze_toclear;$/;"	m	class:Solver
analyze_toclear	sat/test/Solver.h	/^    vec<Lit>            analyze_toclear;$/;"	m	class:Solver
assertProperty	sat/sat.h	/^      void assertProperty(Var prop, bool val) {$/;"	f	class:SatSolver
assertProperty	sat/test/sat.h	/^      void assertProperty(Var prop, bool val) {$/;"	f	class:SatSolver
assigns	sat/Solver.h	/^    vec<char>           assigns;          \/\/ The current assignments (lbool:s stored as char:s).$/;"	m	class:Solver
assigns	sat/VarOrder.h	/^    const vec<char>&    assigns;     \/\/ var->val. Pointer to external assignment table.$/;"	m	class:VarOrder
assigns	sat/test/Solver.h	/^    vec<char>           assigns;          \/\/ The current assignments (lbool:s stored as char:s).$/;"	m	class:Solver
assigns	sat/test/VarOrder.h	/^    const vec<char>&    assigns;     \/\/ var->val. Pointer to external assignment table.$/;"	m	class:VarOrder
assume	sat/Solver.cpp	/^bool Solver::assume(Lit p) {$/;"	f	class:Solver
assume	sat/test/Solver.cpp	/^bool Solver::assume(Lit p) {$/;"	f	class:Solver
assumeProperty	sat/sat.h	/^      void assumeProperty(Var prop, bool val) {$/;"	f	class:SatSolver
assumeProperty	sat/test/sat.h	/^      void assumeProperty(Var prop, bool val) {$/;"	f	class:SatSolver
assumeRelease	sat/sat.h	/^      void assumeRelease() { _assump.clear(); }$/;"	f	class:SatSolver
assumeRelease	sat/test/sat.h	/^      void assumeRelease() { _assump.clear(); }$/;"	f	class:SatSolver
assumpSolve	sat/sat.h	/^      bool assumpSolve() { return _solver->solve(_assump); }$/;"	f	class:SatSolver
assumpSolve	sat/test/sat.h	/^      bool assumpSolve() { return _solver->solve(_assump); }$/;"	f	class:SatSolver
begin	util/myHashMap.h	/^   iterator begin() const {$/;"	f	class:HashMap
begin	util/myHashSet.h	/^   iterator begin() const {$/;"	f	class:HashSet
beginChain	sat/Proof.cpp	/^void Proof::beginChain(ClauseId start)$/;"	f	class:Proof
beginChain	sat/test/Proof.cpp	/^void Proof::beginChain(ClauseId start)$/;"	f	class:Proof
bucketNum	util/myHashMap.h	/^   size_t bucketNum(const HashKey& k) const {$/;"	f	class:HashMap
bucketNum	util/myHashSet.h	/^   size_t bucketNum(const Data& d) const {$/;"	f	class:HashSet
buf	cir/cirMgr.cpp	/^static char buf[1024];$/;"	v	file:
buf	sat/File.h	/^    uchar*      buf;        \/\/ Read or write buffer.$/;"	m	class:File
buf	sat/test/File.h	/^    uchar*      buf;        \/\/ Read or write buffer.$/;"	m	class:File
cancelUntil	sat/Solver.cpp	/^void Solver::cancelUntil(int level) {$/;"	f	class:Solver
cancelUntil	sat/test/Solver.cpp	/^void Solver::cancelUntil(int level) {$/;"	f	class:Solver
cap	sat/Global.h	/^    int cap;$/;"	m	class:vec
cap	sat/test/Global.h	/^    int cap;$/;"	m	class:vec
capacity	sat/Global.h	/^    void     capacity (int size) { grow(size); }$/;"	f	class:vec
capacity	sat/test/Global.h	/^    void     capacity (int size) { grow(size); }$/;"	f	class:vec
cchar	sat/Global.h	/^typedef const char    cchar;$/;"	t
cchar	sat/test/Global.h	/^typedef const char    cchar;$/;"	t
chain_id	sat/Proof.h	/^    vec<ClauseId>   chain_id;$/;"	m	class:Proof
chain_id	sat/test/Proof.h	/^    vec<ClauseId>   chain_id;$/;"	m	class:Proof
chain_lit	sat/Proof.h	/^    vec<Lit>        chain_lit;$/;"	m	class:Proof
chain_lit	sat/test/Proof.h	/^    vec<Lit>        chain_lit;$/;"	m	class:Proof
changeToAIG	cir/cirGate.cpp	/^CirGate::changeToAIG(size_t ln) {$/;"	f	class:CirGate
check	sat/Solver.h	/^inline void check(bool expr) { assert(expr); }$/;"	f
check	sat/test/Solver.h	/^inline void check(bool expr) { assert(expr); }$/;"	f
check	util/myHashMap.h	/^   bool check(const HashKey& k) const {$/;"	f	class:HashMap
check	util/myHashSet.h	/^   bool check(const Data& d) const {$/;"	f	class:HashSet
checkMem	util/myUsage.h	/^   double checkMem() const {$/;"	f	class:MyUsage
checkNoDel	cir/cirMgr.cpp	/^CirParseError checkNoDel(ifstream& fin, string errStr){$/;"	f
checkPO	cir/cirGate.cpp	/^CirGate::checkPO(CirGate* gate) {$/;"	f	class:CirGate
checkStr	cir/cirMgr.cpp	/^bool checkStr(string& s){$/;"	f
checkTick	util/myUsage.h	/^   double checkTick() const {$/;"	f	class:MyUsage
claBumpActivity	sat/Solver.h	/^    void     claBumpActivity (Clause* c) { if ( (c->activity() += cla_inc) > 1e20 ) claRescaleActivity(); }$/;"	f	class:Solver
claBumpActivity	sat/test/Solver.h	/^    void     claBumpActivity (Clause* c) { if ( (c->activity() += cla_inc) > 1e20 ) claRescaleActivity(); }$/;"	f	class:Solver
claDecayActivity	sat/Solver.h	/^    void     claDecayActivity  () { cla_inc *= cla_decay; }$/;"	f	class:Solver
claDecayActivity	sat/test/Solver.h	/^    void     claDecayActivity  () { cla_inc *= cla_decay; }$/;"	f	class:Solver
claRescaleActivity	sat/Solver.cpp	/^void Solver::claRescaleActivity()$/;"	f	class:Solver
claRescaleActivity	sat/test/Solver.cpp	/^void Solver::claRescaleActivity()$/;"	f	class:Solver
cla_decay	sat/Solver.h	/^    double              cla_decay;        \/\/ INVERSE decay factor for clause activity: stores 1\/decay.$/;"	m	class:Solver
cla_decay	sat/test/Solver.h	/^    double              cla_decay;        \/\/ INVERSE decay factor for clause activity: stores 1\/decay.$/;"	m	class:Solver
cla_inc	sat/Solver.h	/^    double              cla_inc;          \/\/ Amount to bump next clause with.$/;"	m	class:Solver
cla_inc	sat/test/Solver.h	/^    double              cla_inc;          \/\/ Amount to bump next clause with.$/;"	m	class:Solver
clause	sat/Proof.h	/^    vec<Lit>        clause;$/;"	m	class:Proof
clause	sat/SolverTypes.h	/^    Clause*     clause   () const { return (Clause*)data; }$/;"	f	class:GClause
clause	sat/test/Proof.h	/^    vec<Lit>        clause;$/;"	m	class:Proof
clause	sat/test/SolverTypes.h	/^    Clause*     clause   () const { return (Clause*)data; }$/;"	f	class:GClause
clause_decay	sat/Solver.h	/^    double  var_decay, clause_decay, random_var_freq;    \/\/ (reasonable values are: 0.95, 0.999, 0.02)    $/;"	m	struct:SearchParams
clause_decay	sat/test/Solver.h	/^    double  var_decay, clause_decay, random_var_freq;    \/\/ (reasonable values are: 0.95, 0.999, 0.02)    $/;"	m	struct:SearchParams
clauses	sat/Solver.h	/^    vec<Clause*>        clauses;          \/\/ List of problem clauses.$/;"	m	class:Solver
clauses	sat/test/Solver.h	/^    vec<Clause*>        clauses;          \/\/ List of problem clauses.$/;"	m	class:Solver
clauses_literals	sat/Solver.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
clauses_literals	sat/test/Solver.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
clear	sat/Global.h	/^void vec<T>::clear(bool dealloc) {$/;"	f	class:vec
clear	sat/test/Global.h	/^void vec<T>::clear(bool dealloc) {$/;"	f	class:vec
clear	util/myHashMap.h	/^   void clear() {$/;"	f	class:HashMap
clear	util/myHashSet.h	/^   void clear() {$/;"	f	class:HashSet
clearList	util/util.h	/^void clearList(T& l)$/;"	f
close	sat/File.cpp	/^void File::close(void)$/;"	f	class:File
close	sat/test/File.cpp	/^void File::close(void)$/;"	f	class:File
colNo	cir/cirMgr.cpp	/^static unsigned colNo  = 0;  \/\/ in printing, colNo needs to ++$/;"	v	file:
collectGrps	cir/cirSim.cpp	/^CirMgr::collectGrps(size_t i, SimHash& h)$/;"	f	class:CirMgr
comp	sat/Heap.h	/^    C        comp;$/;"	m	class:Heap
comp	sat/test/Heap.h	/^    C        comp;$/;"	m	class:Heap
compress	sat/Proof.cpp	/^void Proof::compress(Proof& dst, ClauseId goal)$/;"	f	class:Proof
compress	sat/test/Proof.cpp	/^void Proof::compress(Proof& dst, ClauseId goal)$/;"	f	class:Proof
conflict	sat/Solver.h	/^    vec<Lit>    conflict;           \/\/ If problem is unsatisfiable under assumptions, this vector represent the conflict clause expressed in the assumptions.$/;"	m	class:Solver
conflict	sat/test/Solver.h	/^    vec<Lit>    conflict;           \/\/ If problem is unsatisfiable under assumptions, this vector represent the conflict clause expressed in the assumptions.$/;"	m	class:Solver
conflict_id	sat/Solver.h	/^    ClauseId    conflict_id;        \/\/ (In proof logging mode only.) ID for the clause 'conflict' (for proof traverseral). NOTE! The empty clause is always the last clause derived, but for conflicts under assumption, this is not necessarly true.$/;"	m	class:Solver
conflict_id	sat/test/Solver.h	/^    ClauseId    conflict_id;        \/\/ (In proof logging mode only.) ID for the clause 'conflict' (for proof traverseral). NOTE! The empty clause is always the last clause derived, but for conflicts under assumption, this is not necessarly true.$/;"	m	class:Solver
conflicts	sat/Solver.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
conflicts	sat/test/Solver.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
copyTo	sat/Global.h	/^    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) new (&copy[i]) T(data[i]); }$/;"	f	class:vec
copyTo	sat/test/Global.h	/^    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) new (&copy[i]) T(data[i]); }$/;"	f	class:vec
count	cir/cirMgr.cpp	/^static unsigned count = 0;$/;"	v	file:
cpuTime	sat/Global.h	/^static inline double cpuTime(void) {$/;"	f
cpuTime	sat/test/Global.h	/^static inline double cpuTime(void) {$/;"	f
curCmd	cir/cirCmd.cpp	/^static CirCmdState curCmd = CIRINIT;$/;"	v	file:
data	sat/Global.h	/^    T*  data;$/;"	m	class:vec
data	sat/SolverTypes.h	/^    Lit     data[1];$/;"	m	class:Clause
data	sat/SolverTypes.h	/^    void*   data;$/;"	m	class:GClause
data	sat/test/Global.h	/^    T*  data;$/;"	m	class:vec
data	sat/test/SolverTypes.h	/^    Lit     data[1];$/;"	m	class:Clause
data	sat/test/SolverTypes.h	/^    void*   data;$/;"	m	class:GClause
decisionLevel	sat/Solver.h	/^    int      decisionLevel() const { return trail_lim.size(); }$/;"	f	class:Solver
decisionLevel	sat/test/Solver.h	/^    int      decisionLevel() const { return trail_lim.size(); }$/;"	f	class:Solver
decisions	sat/Solver.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
decisions	sat/test/Solver.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
decode64	sat/File.h	/^static inline int64  decode64(uint64 val)           { return ((val & 1) == 0) ? (int64)(val >> 1) : ~(int64)(val >> 1); }$/;"	f
decode64	sat/test/File.h	/^static inline int64  decode64(uint64 val)           { return ((val & 1) == 0) ? (int64)(val >> 1) : ~(int64)(val >> 1); }$/;"	f
default_params	sat/Solver.h	/^    SearchParams    default_params;     \/\/ Restart frequency etc.$/;"	m	class:Solver
default_params	sat/test/Solver.h	/^    SearchParams    default_params;     \/\/ Restart frequency etc.$/;"	m	class:Solver
deleteId	cir/cirGate.cpp	/^void deleteId(IdList& v, size_t id){$/;"	f
deleted	sat/Proof.cpp	/^void Proof::deleted(ClauseId gone)$/;"	f	class:Proof
deleted	sat/Proof.h	/^    virtual void deleted(ClauseId c){}$/;"	f	struct:ProofTraverser
deleted	sat/test/Proof.cpp	/^void Proof::deleted(ClauseId gone)$/;"	f	class:Proof
deleted	sat/test/Proof.h	/^    virtual void deleted(ClauseId c){}$/;"	f	struct:ProofTraverser
drand	sat/Global.h	/^static inline double drand(double& seed) {$/;"	f
drand	sat/test/Global.h	/^static inline double drand(double& seed) {$/;"	f
eatOneNum	cir/cirMgr.cpp	/^CirParseError eatOneNum(ifstream& fin, string errStr, string& buff, int& d){$/;"	f
eatOneSpace	cir/cirMgr.cpp	/^CirParseError eatOneSpace(ifstream& fin, string errStr){$/;"	f
effLimit	sat/Solver.cpp	/^int effLimit = INT_MAX;$/;"	v
effLimit	sat/test/Solver.cpp	/^int effLimit = INT_MAX;$/;"	v
empty	sat/Heap.h	/^    bool empty     ()         { return heap.size() == 1; }$/;"	f	class:Heap
empty	sat/test/Heap.h	/^    bool empty     ()         { return heap.size() == 1; }$/;"	f	class:Heap
empty	util/myHashMap.h	/^   bool empty() const { return size() == 0; }$/;"	f	class:HashMap
empty	util/myHashSet.h	/^   bool empty() const { return size() == 0; }$/;"	f	class:HashSet
encode64	sat/File.h	/^static inline uint64 encode64(int64  val)           { return (val >= 0) ? (uint64)val << 1 : (((uint64)(~val) << 1) | 1); }$/;"	f
encode64	sat/test/File.h	/^static inline uint64 encode64(int64  val)           { return (val >= 0) ? (uint64)val << 1 : (((uint64)(~val) << 1) | 1); }$/;"	f
end	util/myHashMap.h	/^   iterator end() const {$/;"	f	class:HashMap
end	util/myHashSet.h	/^   iterator end() const {$/;"	f	class:HashSet
endChain	sat/Proof.cpp	/^ClauseId Proof::endChain()$/;"	f	class:Proof
endChain	sat/test/Proof.cpp	/^ClauseId Proof::endChain()$/;"	f	class:Proof
endFraig	cir/cirFraig.cpp	/^CirMgr::endFraig()$/;"	f	class:CirMgr
enqueue	sat/Solver.cpp	/^bool Solver::enqueue(Lit p, Clause* from)$/;"	f	class:Solver
enqueue	sat/test/Solver.cpp	/^bool Solver::enqueue(Lit p, Clause* from)$/;"	f	class:Solver
eof	sat/File.h	/^    bool eof(void) {$/;"	f	class:File
eof	sat/test/File.h	/^    bool eof(void) {$/;"	f	class:File
erase	cir/cirMgr.cpp	/^FecGrp::erase(unsigned x) {$/;"	f	class:FecGrp
errGate	cir/cirMgr.cpp	/^static CirGate *errGate;$/;"	v	file:
errInt	cir/cirMgr.cpp	/^static int errInt;$/;"	v	file:
errMsg	cir/cirMgr.cpp	/^static string errMsg;$/;"	v	file:
exec	cir/cirCmd.cpp	/^CirFraigCmd::exec(const string& option)$/;"	f	class:CirFraigCmd
exec	cir/cirCmd.cpp	/^CirGateCmd::exec(const string& option)$/;"	f	class:CirGateCmd
exec	cir/cirCmd.cpp	/^CirOptCmd::exec(const string& option)$/;"	f	class:CirOptCmd
exec	cir/cirCmd.cpp	/^CirPrintCmd::exec(const string& option)$/;"	f	class:CirPrintCmd
exec	cir/cirCmd.cpp	/^CirReadCmd::exec(const string& option)$/;"	f	class:CirReadCmd
exec	cir/cirCmd.cpp	/^CirSimCmd::exec(const string& option)$/;"	f	class:CirSimCmd
exec	cir/cirCmd.cpp	/^CirStrashCmd::exec(const string& option)$/;"	f	class:CirStrashCmd
exec	cir/cirCmd.cpp	/^CirSweepCmd::exec(const string& option)$/;"	f	class:CirSweepCmd
exec	cir/cirCmd.cpp	/^CirWriteCmd::exec(const string& option)$/;"	f	class:CirWriteCmd
expensive_ccmin	sat/Solver.h	/^    int             expensive_ccmin;    \/\/ Controls conflict clause minimization. TRUE by default.$/;"	m	class:Solver
expensive_ccmin	sat/test/Solver.h	/^    int             expensive_ccmin;    \/\/ Controls conflict clause minimization. TRUE by default.$/;"	m	class:Solver
fd	sat/File.h	/^    int         fd;         \/\/ Underlying file descriptor.$/;"	m	class:File
fd	sat/test/File.h	/^    int         fd;         \/\/ Underlying file descriptor.$/;"	m	class:File
fileSim	cir/cirSim.cpp	/^CirMgr::fileSim(ifstream& patternFile)$/;"	f	class:CirMgr
files	sat/Proof.cpp	/^    vec<cchar*> files;      \/\/ For clean-up purposed on abnormal exit.$/;"	m	class:TempFiles	file:
files	sat/test/Proof.cpp	/^    vec<cchar*> files;      \/\/ For clean-up purposed on abnormal exit.$/;"	m	class:TempFiles	file:
findFECs	cir/cirSim.cpp	/^CirMgr::findFECs()$/;"	f	class:CirMgr
findNonFloating	cir/cirMgr.cpp	/^CirMgr::findNonFloating(CirGate* gate){$/;"	f	class:CirMgr
flush	sat/File.h	/^    void flush(void) {$/;"	f	class:File
flush	sat/test/File.h	/^    void flush(void) {$/;"	f	class:File
fp	sat/Proof.h	/^    File            fp;$/;"	m	class:Proof
fp	sat/test/Proof.h	/^    File            fp;$/;"	m	class:Proof
fp_name	sat/Proof.h	/^    cchar*          fp_name;$/;"	m	class:Proof
fp_name	sat/test/Proof.h	/^    cchar*          fp_name;$/;"	m	class:Proof
fpos	sat/Proof.h	/^    int64           fpos;$/;"	m	class:Proof
fpos	sat/test/Proof.h	/^    int64           fpos;$/;"	m	class:Proof
fraig	cir/cirFraig.cpp	/^CirMgr::fraig()$/;"	f	class:CirMgr
fraigMerge	cir/cirGate.cpp	/^CirGate::fraigMerge(CirGate* gate)$/;"	f	class:CirGate
fst	util/myHashMap.h	/^#define fst /;"	d
gates	sat/test/satTest.cpp	/^vector<Gate *> gates;$/;"	v
genKey	cir/cirFraig.cpp	/^size_t genKey(unsigned x, unsigned y)$/;"	f
genProofModel	cir/cirFraig.cpp	/^CirMgr::genProofModel(SatSolver& s, CirGate* gate)$/;"	f	class:CirMgr
genProofModel	sat/test/satTest.cpp	/^genProofModel(SatSolver& s)$/;"	f
getBase	cir/cirMgr.h	/^   unsigned getBase() const { return _base; }$/;"	f	class:FecGrp
getChar	sat/File.h	/^    int getChar(void) {$/;"	f	class:File
getChar	sat/test/File.h	/^    int getChar(void) {$/;"	f	class:File
getCharQ	sat/File.h	/^    int getCharQ(void) {            \/\/ Quick version with minimal overhead -- don't call this in the wrong mode!$/;"	f	class:File
getCharQ	sat/test/File.h	/^    int getCharQ(void) {            \/\/ Quick version with minimal overhead -- don't call this in the wrong mode!$/;"	f	class:File
getFanin	cir/cirGate.h	/^   IdList& getFanin() { return _faninList; }$/;"	f	class:CirGate
getFanout	cir/cirGate.h	/^   IdList& getFanout() { return _fanoutList; }$/;"	f	class:CirGate
getGate	cir/cirGate.cpp	/^CirGate* CirGate::getGate(size_t x) const { return _mgr->_gateList[x \/ 2]; }$/;"	f	class:CirGate
getGate	cir/cirMgr.h	/^   CirGate* getGate(unsigned gid) const { return gid < _gateList.size()? _gateList[gid]:0; }$/;"	f	class:CirMgr
getHashSize	util/util.cpp	/^size_t getHashSize(size_t s) {$/;"	f
getId	cir/cirGate.h	/^   int getId() const { return _gid; }$/;"	f	class:CirGate
getInt	sat/File.h	/^static inline uint64 getInt  (File& in)             { return decode64(getUInt(in)); }$/;"	f
getInt	sat/test/File.h	/^static inline uint64 getInt  (File& in)             { return decode64(getUInt(in)); }$/;"	f
getLineNo	cir/cirGate.h	/^   unsigned getLineNo() const { return lineNum; }$/;"	f	class:CirGate
getMode	sat/File.h	/^    FileMode getMode(void) {$/;"	f	class:File
getMode	sat/test/File.h	/^    FileMode getMode(void) {$/;"	f	class:File
getOptCmd	cmd/cmdParser.h	/^   const string& getOptCmd() const { return _optCmd; }$/;"	f	class:CmdExec
getPos	cir/cirGate.h	/^   unsigned getPos() const { return _pos; }$/;"	f	class:CirGate
getSimVal	cir/cirGate.h	/^   const SimValue& getSimVal() const { return _val; }$/;"	f	class:CirGate
getSymbol	cir/cirGate.h	/^   virtual string getSymbol() const { return ""; }$/;"	f	class:CirGate
getSymbol	cir/cirGate.h	/^   virtual string getSymbol() const { return _sym; }$/;"	f	class:CirPIGate
getSymbol	cir/cirGate.h	/^   virtual string getSymbol() const { return _sym; }$/;"	f	class:CirPOGate
getTypeStr	cir/cirGate.h	/^   virtual string getTypeStr() const { return "AIG"; }$/;"	f	class:CirAIGGate
getTypeStr	cir/cirGate.h	/^   virtual string getTypeStr() const { return "CONST"; }$/;"	f	class:CirCONSTGate
getTypeStr	cir/cirGate.h	/^   virtual string getTypeStr() const { return "PI"; }$/;"	f	class:CirPIGate
getTypeStr	cir/cirGate.h	/^   virtual string getTypeStr() const { return "PO"; }$/;"	f	class:CirPOGate
getTypeStr	cir/cirGate.h	/^   virtual string getTypeStr() const { return "UNDEF"; }$/;"	f	class:CirGate
getUInt	sat/File.cpp	/^uint64 getUInt(File& in)$/;"	f
getUInt	sat/test/File.cpp	/^uint64 getUInt(File& in)$/;"	f
getValue	sat/sat.h	/^      int getValue(Var v) const {$/;"	f	class:SatSolver
getValue	sat/test/sat.h	/^      int getValue(Var v) const {$/;"	f	class:SatSolver
getVar	cir/cirGate.h	/^   virtual const Var getVar() const { return -1; }$/;"	f	class:CirGate
getVar	cir/cirGate.h	/^   virtual const Var getVar() const { return _var; }$/;"	f	class:CirAIGGate
getVar	cir/cirGate.h	/^   virtual const Var getVar() const { return _var; }$/;"	f	class:CirCONSTGate
getVar	cir/cirGate.h	/^   virtual const Var getVar() const { return _var; }$/;"	f	class:CirPIGate
getVar	cir/cirGate.h	/^   virtual const Var getVar() const { return _var; }$/;"	f	class:CirUNDEFGate
getVar	sat/test/satTest.cpp	/^   Var getVar() const { return _var; }$/;"	f	class:Gate
getmin	sat/Heap.h	/^    int  getmin() {$/;"	f	class:Heap
getmin	sat/test/Heap.h	/^    int  getmin() {$/;"	f	class:Heap
grow	sat/Global.h	/^void vec<T>::grow(int min_cap) {$/;"	f	class:vec
grow	sat/test/Global.h	/^void vec<T>::grow(int min_cap) {$/;"	f	class:vec
growTo	sat/Global.h	/^void vec<T>::growTo(int size) {$/;"	f	class:vec
growTo	sat/Global.h	/^void vec<T>::growTo(int size, const T& pad) {$/;"	f	class:vec
growTo	sat/test/Global.h	/^void vec<T>::growTo(int size) {$/;"	f	class:vec
growTo	sat/test/Global.h	/^void vec<T>::growTo(int size, const T& pad) {$/;"	f	class:vec
hash	sat/SolverTypes.h	/^    uint hash() const { return (uint)x; }$/;"	f	class:Lit
hash	sat/test/SolverTypes.h	/^    uint hash() const { return (uint)x; }$/;"	f	class:Lit
heap	sat/Heap.h	/^    vec<int> heap;     \/\/ heap of ints$/;"	m	class:Heap
heap	sat/VarOrder.h	/^    Heap<VarOrder_lt>   heap;$/;"	m	class:VarOrder
heap	sat/test/Heap.h	/^    vec<int> heap;     \/\/ heap of ints$/;"	m	class:Heap
heap	sat/test/VarOrder.h	/^    Heap<VarOrder_lt>   heap;$/;"	m	class:VarOrder
heapProperty	sat/Heap.h	/^    bool heapProperty() {$/;"	f	class:Heap
heapProperty	sat/Heap.h	/^    bool heapProperty(int i) {$/;"	f	class:Heap
heapProperty	sat/test/Heap.h	/^    bool heapProperty() {$/;"	f	class:Heap
heapProperty	sat/test/Heap.h	/^    bool heapProperty(int i) {$/;"	f	class:Heap
help	cir/cirCmd.cpp	/^CirFraigCmd::help() const$/;"	f	class:CirFraigCmd
help	cir/cirCmd.cpp	/^CirGateCmd::help() const$/;"	f	class:CirGateCmd
help	cir/cirCmd.cpp	/^CirOptCmd::help() const$/;"	f	class:CirOptCmd
help	cir/cirCmd.cpp	/^CirPrintCmd::help() const$/;"	f	class:CirPrintCmd
help	cir/cirCmd.cpp	/^CirReadCmd::help() const$/;"	f	class:CirReadCmd
help	cir/cirCmd.cpp	/^CirSimCmd::help() const$/;"	f	class:CirSimCmd
help	cir/cirCmd.cpp	/^CirStrashCmd::help() const$/;"	f	class:CirStrashCmd
help	cir/cirCmd.cpp	/^CirSweepCmd::help() const$/;"	f	class:CirSweepCmd
help	cir/cirCmd.cpp	/^CirWriteCmd::help() const$/;"	f	class:CirWriteCmd
id	sat/SolverTypes.h	/^    ClauseId& id          ()      const { return *((ClauseId*)&data[size() + (int)learnt()]); }$/;"	f	class:Clause
id	sat/SolverTypes.h	/^inline Lit  id    (Lit p, bool sgn) { Lit q; q.x = p.x ^ (int)sgn; return q; }$/;"	f
id	sat/test/SolverTypes.h	/^    ClauseId& id          ()      const { return *((ClauseId*)&data[size() + (int)learnt()]); }$/;"	f	class:Clause
id	sat/test/SolverTypes.h	/^inline Lit  id    (Lit p, bool sgn) { Lit q; q.x = p.x ^ (int)sgn; return q; }$/;"	f
id_counter	sat/Proof.h	/^    ClauseId        id_counter;$/;"	m	class:Proof
id_counter	sat/test/Proof.h	/^    ClauseId        id_counter;$/;"	m	class:Proof
inHeap	sat/Heap.h	/^    bool inHeap    (int n)    { assert(ok(n)); return indices[n] != 0; }$/;"	f	class:Heap
inHeap	sat/test/Heap.h	/^    bool inHeap    (int n)    { assert(ok(n)); return indices[n] != 0; }$/;"	f	class:Heap
increase	sat/Heap.h	/^    void increase  (int n)    { assert(ok(n)); assert(inHeap(n)); percolateUp(indices[n]); }$/;"	f	class:Heap
increase	sat/test/Heap.h	/^    void increase  (int n)    { assert(ok(n)); assert(inHeap(n)); percolateUp(indices[n]); }$/;"	f	class:Heap
index	sat/SolverTypes.h	/^inline int  index (Lit p) { return p.x; }                \/\/ A "toInt" method that guarantees small, positive integers suitable for array indexing.$/;"	f
index	sat/test/SolverTypes.h	/^inline int  index (Lit p) { return p.x; }                \/\/ A "toInt" method that guarantees small, positive integers suitable for array indexing.$/;"	f
indices	sat/Heap.h	/^    vec<int> indices;  \/\/ int -> index in heap$/;"	m	class:Heap
indices	sat/test/Heap.h	/^    vec<int> indices;  \/\/ int -> index in heap$/;"	m	class:Heap
init	util/myHashMap.h	/^   void init(size_t b) {$/;"	f	class:HashMap
init	util/myHashMap.h	/^   void init(size_t s) { reset(); _size = s; _cache = new CacheNode[s]; }$/;"	f	class:Cache
init	util/myHashSet.h	/^   void init(size_t b) { _numBuckets = b; _buckets = new vector<Data>[b]; }$/;"	f	class:HashSet
initCirCmd	cir/cirCmd.cpp	/^initCirCmd()$/;"	f
initCircuit	sat/test/satTest.cpp	/^initCircuit()$/;"	f
initSat	cir/cirFraig.cpp	/^CirMgr::initSat(SatSolver& s, CirGate* base, CirGate* gate)$/;"	f	class:CirMgr
initialize	sat/sat.h	/^      void initialize() {$/;"	f	class:SatSolver
initialize	sat/test/sat.h	/^      void initialize() {$/;"	f	class:SatSolver
insert	sat/Heap.h	/^    void insert(int n) {$/;"	f	class:Heap
insert	sat/test/Heap.h	/^    void insert(int n) {$/;"	f	class:Heap
insert	util/myHashMap.h	/^   bool insert(const HashKey& k, const HashData& d) {$/;"	f	class:HashMap
insert	util/myHashSet.h	/^   bool insert(const Data& d) {$/;"	f	class:HashSet
int64	sat/Global.h	/^typedef INT64              int64;$/;"	t
int64	sat/Global.h	/^typedef long long          int64;$/;"	t
int64	sat/test/Global.h	/^typedef INT64              int64;$/;"	t
int64	sat/test/Global.h	/^typedef long long          int64;$/;"	t
intp	sat/Global.h	/^typedef INT_PTR            intp;$/;"	t
intp	sat/Global.h	/^typedef __PTRDIFF_TYPE__   intp;$/;"	t
intp	sat/test/Global.h	/^typedef INT_PTR            intp;$/;"	t
intp	sat/test/Global.h	/^typedef __PTRDIFF_TYPE__   intp;$/;"	t
irand	sat/Global.h	/^static inline int irand(double& seed, int size) {$/;"	f
irand	sat/test/Global.h	/^static inline int irand(double& seed, int size) {$/;"	f
isActive	cir/cirGate.cpp	/^bool CirGate::isActive() const { return _ref == _globalRef; }$/;"	f	class:CirGate
isAig	cir/cirGate.h	/^   virtual bool isAig() const { return false; }$/;"	f	class:CirGate
isAig	cir/cirGate.h	/^   virtual bool isAig() const { return true; }$/;"	f	class:CirAIGGate
isCONST	cir/cirGate.h	/^   virtual bool isCONST() const { return false; }$/;"	f	class:CirGate
isCONST	cir/cirGate.h	/^   virtual bool isCONST() const { return true; }   $/;"	f	class:CirCONSTGate
isInv	cir/cirDef.h	/^   bool isInv (const SimValue& sv) const { return (!(*this)) == sv; }$/;"	f	class:SimValue
isLit	sat/SolverTypes.h	/^    bool        isLit    () const { return ((uintp)data & 1) == 1; }$/;"	f	class:GClause
isLit	sat/test/SolverTypes.h	/^    bool        isLit    () const { return ((uintp)data & 1) == 1; }$/;"	f	class:GClause
isPI	cir/cirGate.h	/^   virtual bool isPI() const { return false; }$/;"	f	class:CirGate
isPI	cir/cirGate.h	/^   virtual bool isPI() const { return true; }$/;"	f	class:CirPIGate
isPO	cir/cirGate.h	/^   virtual bool isPO() const { return false; }$/;"	f	class:CirGate
isPO	cir/cirGate.h	/^   virtual bool isPO() const { return true; }$/;"	f	class:CirPOGate
isSingleton	cir/cirMgr.h	/^   bool isSingleton() { return _data.size() == 1; }$/;"	f	class:FecGrp
isUNDEF	cir/cirGate.h	/^   virtual bool isUNDEF() const { return false; }$/;"	f	class:CirGate
isUNDEF	cir/cirGate.h	/^   virtual bool isUNDEF() const { return true; }$/;"	f	class:CirUNDEFGate
isValidVarName	util/myString.cpp	/^isValidVarName(const string& str)$/;"	f
iterator	util/myHashMap.h	/^      iterator(size_t n, size_t cb, vector<HashNode>* v, typename vector<HashNode>::iterator it)$/;"	f	class:HashMap::iterator
iterator	util/myHashMap.h	/^   class iterator$/;"	c	class:HashMap
iterator	util/myHashSet.h	/^      iterator(size_t n, size_t cb, vector<Data>* v, typename vector<Data>::iterator it)$/;"	f	class:HashSet::iterator
iterator	util/myHashSet.h	/^   class iterator$/;"	c	class:HashSet
l_False	sat/Global.h	/^const lbool l_False = toLbool(-1);$/;"	v
l_False	sat/test/Global.h	/^const lbool l_False = toLbool(-1);$/;"	v
l_True	sat/Global.h	/^const lbool l_True  = toLbool( 1);$/;"	v
l_True	sat/test/Global.h	/^const lbool l_True  = toLbool( 1);$/;"	v
l_Undef	sat/Global.h	/^const lbool l_Undef = toLbool( 0);$/;"	v
l_Undef	sat/test/Global.h	/^const lbool l_Undef = toLbool( 0);$/;"	v
last	sat/Global.h	/^    T&       last  (void)              { return data[sz-1]; }$/;"	f	class:vec
last	sat/Global.h	/^    const T& last  (void) const        { return data[sz-1]; }$/;"	f	class:vec
last	sat/Proof.h	/^    ClauseId last      () { assert(id_counter != ClauseId_NULL); return id_counter - 1; }$/;"	f	class:Proof
last	sat/test/Global.h	/^    T&       last  (void)              { return data[sz-1]; }$/;"	f	class:vec
last	sat/test/Global.h	/^    const T& last  (void) const        { return data[sz-1]; }$/;"	f	class:vec
last	sat/test/Proof.h	/^    ClauseId last      () { assert(id_counter != ClauseId_NULL); return id_counter - 1; }$/;"	f	class:Proof
lastToFirst_lt	sat/Solver.cpp	/^    lastToFirst_lt(const vec<int>& t) : trail_pos(t) {}$/;"	f	class:lastToFirst_lt
lastToFirst_lt	sat/Solver.cpp	/^class lastToFirst_lt {  \/\/ Helper class to 'analyze' -- order literals from last to first occurance in 'trail[]'.$/;"	c	file:
lastToFirst_lt	sat/test/Solver.cpp	/^    lastToFirst_lt(const vec<int>& t) : trail_pos(t) {}$/;"	f	class:lastToFirst_lt
lastToFirst_lt	sat/test/Solver.cpp	/^class lastToFirst_lt {  \/\/ Helper class to 'analyze' -- order literals from last to first occurance in 'trail[]'.$/;"	c	file:
lbool	sat/Global.h	/^    explicit lbool(int v) : value(v) { }$/;"	f	class:lbool
lbool	sat/Global.h	/^    lbool()       : value(0) { }$/;"	f	class:lbool
lbool	sat/Global.h	/^    lbool(bool x) : value((int)x*2-1) { }$/;"	f	class:lbool
lbool	sat/Global.h	/^class lbool {$/;"	c
lbool	sat/test/Global.h	/^    explicit lbool(int v) : value(v) { }$/;"	f	class:lbool
lbool	sat/test/Global.h	/^    lbool()       : value(0) { }$/;"	f	class:lbool
lbool	sat/test/Global.h	/^    lbool(bool x) : value((int)x*2-1) { }$/;"	f	class:lbool
lbool	sat/test/Global.h	/^class lbool {$/;"	c
learnt	sat/SolverTypes.h	/^    bool      learnt      ()      const { return size_learnt & 1; }$/;"	f	class:Clause
learnt	sat/test/SolverTypes.h	/^    bool      learnt      ()      const { return size_learnt & 1; }$/;"	f	class:Clause
learnts	sat/Solver.h	/^    vec<Clause*>        learnts;          \/\/ List of learnt clauses.$/;"	m	class:Solver
learnts	sat/test/Solver.h	/^    vec<Clause*>        learnts;          \/\/ List of learnt clauses.$/;"	m	class:Solver
learnts_literals	sat/Solver.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
learnts_literals	sat/test/Solver.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
left	sat/Heap.h	/^static inline int left  (int i) { return i+i; }$/;"	f
left	sat/test/Heap.h	/^static inline int left  (int i) { return i+i; }$/;"	f
level	sat/Solver.h	/^    vec<int>            level;            \/\/ 'level[var]' is the decision level at which assignment was made.$/;"	m	class:Solver
level	sat/test/Solver.h	/^    vec<int>            level;            \/\/ 'level[var]' is the decision level at which assignment was made.$/;"	m	class:Solver
lineNo	cir/cirMgr.cpp	/^static unsigned lineNo = 0;  \/\/ in printint, lineNo needs to ++$/;"	v	file:
lineNum	cir/cirGate.h	/^   size_t           lineNum;$/;"	m	class:CirGate
listDir	util/util.cpp	/^int listDir$/;"	f
lit	sat/SolverTypes.h	/^    Lit         lit      () const { return toLit(((intp)data) >> 1); }$/;"	f	class:GClause
lit	sat/test/SolverTypes.h	/^    Lit         lit      () const { return toLit(((intp)data) >> 1); }$/;"	f	class:GClause
locked	sat/Solver.h	/^    bool     locked          (const Clause* c) const { return reason[var((*c)[0])] == c; }$/;"	f	class:Solver
locked	sat/test/Solver.h	/^    bool     locked          (const Clause* c) const { return reason[var((*c)[0])] == c; }$/;"	f	class:Solver
lseek64	sat/File.h	/^#define lseek64 /;"	d
lseek64	sat/test/File.h	/^#define lseek64 /;"	d
main	main/main.cpp	/^main(int argc, char** argv)$/;"	f
main	sat/test/satTest.cpp	/^int main()$/;"	f
max	sat/Global.h	/^template<class T> static inline T max(T x, T y) { return (x > y) ? x : y; }$/;"	f
max	sat/test/Global.h	/^template<class T> static inline T max(T x, T y) { return (x > y) ? x : y; }$/;"	f
max_literals	sat/Solver.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
max_literals	sat/test/Solver.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
memReadStat	sat/Global.h	/^static inline int memReadStat(int field)$/;"	f
memReadStat	sat/test/Global.h	/^static inline int memReadStat(int field)$/;"	f
memUsed	sat/Global.h	/^static inline int64 memUsed() { return (int64)memReadStat(0) * (int64)getpagesize(); }$/;"	f
memUsed	sat/Global.h	/^static inline int64 memUsed() {$/;"	f
memUsed	sat/test/Global.h	/^static inline int64 memUsed() { return (int64)memReadStat(0) * (int64)getpagesize(); }$/;"	f
memUsed	sat/test/Global.h	/^static inline int64 memUsed() {$/;"	f
min	sat/Global.h	/^template<class T> static inline T min(T x, T y) { return (x < y) ? x : y; }$/;"	f
min	sat/test/Global.h	/^template<class T> static inline T min(T x, T y) { return (x < y) ? x : y; }$/;"	f
mode	sat/File.h	/^    FileMode    mode;       \/\/ Reading or writing.$/;"	m	class:File
mode	sat/test/File.h	/^    FileMode    mode;       \/\/ Reading or writing.$/;"	m	class:File
model	sat/Solver.h	/^    vec<lbool>  model;              \/\/ If problem is satisfiable, this vector contains the model (if any).$/;"	m	class:Solver
model	sat/test/Solver.h	/^    vec<lbool>  model;              \/\/ If problem is satisfiable, this vector contains the model (if any).$/;"	m	class:Solver
modelValue	sat/Solver.h	/^    lbool   modelValue(Var x) const { return model[x]; }$/;"	f	class:Solver
modelValue	sat/test/Solver.h	/^    lbool   modelValue(Var x) const { return model[x]; }$/;"	f	class:Solver
moveTo	sat/Global.h	/^    void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }$/;"	f	class:vec
moveTo	sat/test/Global.h	/^    void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }$/;"	f	class:vec
myGetChar	util/myGetChar.cpp	/^char myGetChar()$/;"	f
myGetChar	util/myGetChar.cpp	/^char myGetChar(istream& istr)$/;"	f
myStr2Int	util/myString.cpp	/^myStr2Int(const string& str, int& num)$/;"	f
myStrGetTok	util/myString.cpp	/^myStrGetTok(const string& str, string& tok, size_t pos = 0,$/;"	f
myStrNCmp	util/myString.cpp	/^myStrNCmp(const string& s1, const string& s2, unsigned n)$/;"	f
myUsage	util/util.cpp	/^MyUsage       myUsage;$/;"	v
my_random	util/rnGen.h	/^#define my_random /;"	d
my_srandom	util/rnGen.h	/^#define my_srandom /;"	d
myexit	main/main.cpp	/^myexit()$/;"	f	file:
nAssigns	sat/Solver.h	/^    int     nAssigns() { return trail.size(); }$/;"	f	class:Solver
nAssigns	sat/test/Solver.h	/^    int     nAssigns() { return trail.size(); }$/;"	f	class:Solver
nClauses	sat/Solver.h	/^    int     nClauses() { return clauses.size(); }$/;"	f	class:Solver
nClauses	sat/test/Solver.h	/^    int     nClauses() { return clauses.size(); }$/;"	f	class:Solver
nLearnts	sat/Solver.h	/^    int     nLearnts() { return learnts.size(); }$/;"	f	class:Solver
nLearnts	sat/test/Solver.h	/^    int     nLearnts() { return learnts.size(); }$/;"	f	class:Solver
nVars	sat/Solver.h	/^    int     nVars     ()                    { return assigns.size(); }$/;"	f	class:Solver
nVars	sat/test/Solver.h	/^    int     nVars     ()                    { return assigns.size(); }$/;"	f	class:Solver
newClause	sat/Solver.cpp	/^void Solver::newClause(const vec<Lit>& ps_, bool learnt, ClauseId id , bool A)$/;"	f	class:Solver
newClause	sat/test/Solver.cpp	/^void Solver::newClause(const vec<Lit>& ps_, bool learnt, ClauseId id , bool A)$/;"	f	class:Solver
newVar	sat/Solver.cpp	/^Var Solver::newVar() {$/;"	f	class:Solver
newVar	sat/VarOrder.h	/^void VarOrder::newVar(void)$/;"	f	class:VarOrder
newVar	sat/sat.h	/^      inline Var newVar() { _solver->newVar(); return _curVar++; }$/;"	f	class:SatSolver
newVar	sat/test/Solver.cpp	/^Var Solver::newVar() {$/;"	f	class:Solver
newVar	sat/test/VarOrder.h	/^void VarOrder::newVar(void)$/;"	f	class:VarOrder
newVar	sat/test/sat.h	/^      inline Var newVar() { _solver->newVar(); return _curVar++; }$/;"	f	class:SatSolver
null	sat/File.h	/^    bool null(void) {               \/\/ TRUE if no file is opened.$/;"	f	class:File
null	sat/test/File.h	/^    bool null(void) {               \/\/ TRUE if no file is opened.$/;"	f	class:File
numBuckets	util/myHashMap.h	/^   size_t numBuckets() const { return _numBuckets; }$/;"	f	class:HashMap
numBuckets	util/myHashSet.h	/^   size_t numBuckets() const { return _numBuckets; }$/;"	f	class:HashSet
ok	sat/Heap.h	/^    bool ok(int n) { return n >= 0 && n < (int)indices.size(); }$/;"	f	class:Heap
ok	sat/Solver.h	/^    bool                ok;               \/\/ If FALSE, the constraints are already unsatisfiable. No part of the solver state may be used!$/;"	m	class:Solver
ok	sat/test/Heap.h	/^    bool ok(int n) { return n >= 0 && n < (int)indices.size(); }$/;"	f	class:Heap
ok	sat/test/Solver.h	/^    bool                ok;               \/\/ If FALSE, the constraints are already unsatisfiable. No part of the solver state may be used!$/;"	m	class:Solver
okay	sat/Solver.h	/^    bool    okay() { return ok; }       \/\/ FALSE means solver is in an conflicting state (must never be used again!)$/;"	f	class:Solver
okay	sat/test/Solver.h	/^    bool    okay() { return ok; }       \/\/ FALSE means solver is in an conflicting state (must never be used again!)$/;"	f	class:Solver
open	sat/File.cpp	/^void File::open(cchar* name, cchar* mode_)$/;"	f	class:File
open	sat/File.cpp	/^void File::open(int file_descr, FileMode m, bool own)$/;"	f	class:File
open	sat/Proof.cpp	/^    char* open(File& fp)$/;"	f	class:TempFiles
open	sat/test/File.cpp	/^void File::open(cchar* name, cchar* mode_)$/;"	f	class:File
open	sat/test/File.cpp	/^void File::open(int file_descr, FileMode m, bool own)$/;"	f	class:File
open	sat/test/Proof.cpp	/^    char* open(File& fp)$/;"	f	class:TempFiles
open64	sat/File.h	/^#define open64 /;"	d
open64	sat/test/File.h	/^#define open64 /;"	d
operator !	cir/cirDef.h	/^   SimValue operator ! () const { return SimValue(_v ^ INV); }$/;"	f	class:SimValue
operator !=	sat/Global.h	/^    bool  operator != (const lbool& other) const { return value != other.value; }$/;"	f	class:lbool
operator !=	sat/Global.h	/^template <class T> static inline bool operator != (const T& x, const T& y) { return !(x == y); }$/;"	f
operator !=	sat/SolverTypes.h	/^    bool        operator != (GClause c) const { return data != c.data; }$/;"	f	class:GClause
operator !=	sat/test/Global.h	/^    bool  operator != (const lbool& other) const { return value != other.value; }$/;"	f	class:lbool
operator !=	sat/test/Global.h	/^template <class T> static inline bool operator != (const T& x, const T& y) { return !(x == y); }$/;"	f
operator !=	sat/test/SolverTypes.h	/^    bool        operator != (GClause c) const { return data != c.data; }$/;"	f	class:GClause
operator !=	util/myHashMap.h	/^      bool operator != (const iterator& i) const { return _cB != i._cB || _it != i._it; }$/;"	f	class:HashMap::iterator
operator !=	util/myHashSet.h	/^      bool operator != (const iterator& i) const { return _cB != i._cB || _it != i._it; }$/;"	f	class:HashSet::iterator
operator &	cir/cirDef.h	/^   SimValue operator & (const SimValue& sv) const { return SimValue(_v & sv._v); }$/;"	f	class:SimValue
operator ()	cir/cirDef.h	/^   size_t operator () () const { return _v; }$/;"	f	class:SimValue
operator ()	cir/cirDef.h	/^   size_t operator () (const SimValue& sv) const { return sv(); }$/;"	f	struct:SimHasher
operator ()	cir/cirMgr.h	/^   bool operator () (const FecGrp* g1, const FecGrp* g2) const$/;"	f	class:FecCompare
operator ()	sat/Solver.cpp	/^    bool operator () (Lit p, Lit q) { return trail_pos[var(p)] > trail_pos[var(q)]; }$/;"	f	class:lastToFirst_lt
operator ()	sat/Solver.cpp	/^struct reduceDB_lt { bool operator () (Clause* x, Clause* y) { return x->size() > 2 && (y->size() == 2 || x->activity() < y->activity()); } };$/;"	f	struct:reduceDB_lt
operator ()	sat/Sort.h	/^    bool operator () (T x, T y) { return x < y; }$/;"	f	struct:LessThan_default
operator ()	sat/VarOrder.h	/^    bool operator () (Var x, Var y) { return activity[x] > activity[y]; }$/;"	f	struct:VarOrder_lt
operator ()	sat/test/Solver.cpp	/^    bool operator () (Lit p, Lit q) { return trail_pos[var(p)] > trail_pos[var(q)]; }$/;"	f	class:lastToFirst_lt
operator ()	sat/test/Solver.cpp	/^struct reduceDB_lt { bool operator () (Clause* x, Clause* y) { return x->size() > 2 && (y->size() == 2 || x->activity() < y->activity()); } };$/;"	f	struct:reduceDB_lt
operator ()	sat/test/Sort.h	/^    bool operator () (T x, T y) { return x < y; }$/;"	f	struct:LessThan_default
operator ()	sat/test/VarOrder.h	/^    bool operator () (Var x, Var y) { return activity[x] > activity[y]; }$/;"	f	struct:VarOrder_lt
operator ()	util/rnGen.h	/^      const int operator() (const int range) const {$/;"	f	class:RandomNumGen
operator *	util/myHashMap.h	/^      HashData& operator * () { return (*_it).second; }$/;"	f	class:HashMap::iterator
operator *	util/myHashMap.h	/^      const HashData& operator * () const { return (*_it).second; }$/;"	f	class:HashMap::iterator
operator *	util/myHashSet.h	/^      Data& operator * () { return *_it; }$/;"	f	class:HashSet::iterator
operator *	util/myHashSet.h	/^      const Data& operator * () const { return *_it; }$/;"	f	class:HashSet::iterator
operator ++	util/myHashMap.h	/^      iterator operator ++ (int) { iterator temp = *this; ++(*this); return temp; }$/;"	f	class:HashMap::iterator
operator ++	util/myHashMap.h	/^      iterator& operator ++ () {$/;"	f	class:HashMap::iterator
operator ++	util/myHashSet.h	/^      iterator operator ++ (int) { iterator temp = *this; ++(*this); return temp; }$/;"	f	class:HashSet::iterator
operator ++	util/myHashSet.h	/^      iterator& operator ++ () {$/;"	f	class:HashSet::iterator
operator --	util/myHashSet.h	/^      iterator operator -- (int) { iterator temp = *this; --(*this); return temp; }$/;"	f	class:HashSet::iterator
operator --	util/myHashSet.h	/^      iterator& operator -- () {$/;"	f	class:HashSet::iterator
operator <	sat/SolverTypes.h	/^inline bool operator <  (Lit p, Lit q) { return index(p)  < index(q); }  \/\/ '<' guarantees that p, ~p are adjacent in the ordering.$/;"	f
operator <	sat/test/SolverTypes.h	/^inline bool operator <  (Lit p, Lit q) { return index(p)  < index(q); }  \/\/ '<' guarantees that p, ~p are adjacent in the ordering.$/;"	f
operator <<	cir/cirDef.h	/^   friend ostream& operator << (ostream& out, const SimValue& sv){$/;"	f	class:SimValue
operator <<	cir/cirMgr.h	/^   friend ostream& operator << (ostream& out, FecGrp& fg){$/;"	f	class:FecGrp
operator <=	sat/Global.h	/^template <class T> static inline bool operator <= (const T& x, const T& y) { return !(y < x);  }$/;"	f
operator <=	sat/test/Global.h	/^template <class T> static inline bool operator <= (const T& x, const T& y) { return !(y < x);  }$/;"	f
operator =	sat/Global.h	/^    vec<T>&  operator = (vec<T>& other) { TEMPLATE_FAIL; }$/;"	f	class:vec
operator =	sat/test/Global.h	/^    vec<T>&  operator = (vec<T>& other) { TEMPLATE_FAIL; }$/;"	f	class:vec
operator ==	cir/cirDef.h	/^   bool operator == (const SimValue& sv) const { return _v == sv._v; }$/;"	f	class:SimValue
operator ==	sat/Global.h	/^    bool  operator == (const lbool& other) const { return value == other.value; }$/;"	f	class:lbool
operator ==	sat/SolverTypes.h	/^    bool        operator == (GClause c) const { return data == c.data; }$/;"	f	class:GClause
operator ==	sat/SolverTypes.h	/^inline bool operator == (Lit p, Lit q) { return index(p) == index(q); }$/;"	f
operator ==	sat/test/Global.h	/^    bool  operator == (const lbool& other) const { return value == other.value; }$/;"	f	class:lbool
operator ==	sat/test/SolverTypes.h	/^    bool        operator == (GClause c) const { return data == c.data; }$/;"	f	class:GClause
operator ==	sat/test/SolverTypes.h	/^inline bool operator == (Lit p, Lit q) { return index(p) == index(q); }$/;"	f
operator ==	util/myHashMap.h	/^      bool operator == (const iterator& i) const { return _cB == i._cB && _it == i._it; }$/;"	f	class:HashMap::iterator
operator ==	util/myHashSet.h	/^      bool operator == (const iterator& i) const { return _cB == i._cB && _it == i._it; }$/;"	f	class:HashSet::iterator
operator >	sat/Global.h	/^template <class T> static inline bool operator >  (const T& x, const T& y) { return y < x;     }$/;"	f
operator >	sat/test/Global.h	/^template <class T> static inline bool operator >  (const T& x, const T& y) { return y < x;     }$/;"	f
operator >=	sat/Global.h	/^template <class T> static inline bool operator >= (const T& x, const T& y) { return !(x < y);  }$/;"	f
operator >=	sat/test/Global.h	/^template <class T> static inline bool operator >= (const T& x, const T& y) { return !(x < y);  }$/;"	f
operator T*	sat/Global.h	/^    operator T*       (void)           { return data; }     \/\/ (unsafe but convenient)$/;"	f	class:vec
operator T*	sat/test/Global.h	/^    operator T*       (void)           { return data; }     \/\/ (unsafe but convenient)$/;"	f	class:vec
operator []	cir/cirMgr.h	/^   const unsigned& operator [] (size_t i) const { return _data[i]; }$/;"	f	class:FecGrp
operator []	cir/cirMgr.h	/^   unsigned& operator [] (size_t i) { return _data[i]; }$/;"	f	class:FecGrp
operator []	sat/Global.h	/^    T&       operator [] (int index)        { return data[index]; }$/;"	f	class:vec
operator []	sat/Global.h	/^    const T& operator [] (int index) const  { return data[index]; }$/;"	f	class:vec
operator []	sat/SolverTypes.h	/^    Lit       operator [] (int i) const { return data[i]; }$/;"	f	class:Clause
operator []	sat/SolverTypes.h	/^    Lit&      operator [] (int i)       { return data[i]; }$/;"	f	class:Clause
operator []	sat/test/Global.h	/^    T&       operator [] (int index)        { return data[index]; }$/;"	f	class:vec
operator []	sat/test/Global.h	/^    const T& operator [] (int index) const  { return data[index]; }$/;"	f	class:vec
operator []	sat/test/SolverTypes.h	/^    Lit       operator [] (int i) const { return data[i]; }$/;"	f	class:Clause
operator []	sat/test/SolverTypes.h	/^    Lit&      operator [] (int i)       { return data[i]; }$/;"	f	class:Clause
operator []	util/myHashMap.h	/^   CacheNode& operator [] (size_t i) { return _cache[i]; }$/;"	f	class:Cache
operator []	util/myHashMap.h	/^   const CacheNode& operator [](size_t i) const { return _cache[i]; }$/;"	f	class:Cache
operator []	util/myHashMap.h	/^   const vector<HashNode>& operator [](size_t i) const { return _buckets[i]; }$/;"	f	class:HashMap
operator []	util/myHashMap.h	/^   vector<HashNode>& operator [] (size_t i) { return _buckets[i]; }$/;"	f	class:HashMap
operator []	util/myHashSet.h	/^   const vector<Data>& operator [](size_t i) const { return _buckets[i]; }$/;"	f	class:HashSet
operator []	util/myHashSet.h	/^   vector<Data>& operator [] (size_t i) { return _buckets[i]; }$/;"	f	class:HashSet
operator const T*	sat/Global.h	/^    operator const T* (void) const     { return data; }$/;"	f	class:vec
operator const T*	sat/test/Global.h	/^    operator const T* (void) const     { return data; }$/;"	f	class:vec
operator |	cir/cirDef.h	/^   SimValue operator | (const SimValue& sv) const { return SimValue(_v | sv._v); }$/;"	f	class:SimValue
operator ~	sat/Global.h	/^    lbool operator ~  (void)               const { return lbool(-value); }$/;"	f	class:lbool
operator ~	sat/SolverTypes.h	/^inline Lit operator ~ (Lit p) { Lit q; q.x = p.x ^ 1; return q; }$/;"	f
operator ~	sat/test/Global.h	/^    lbool operator ~  (void)               const { return lbool(-value); }$/;"	f	class:lbool
operator ~	sat/test/SolverTypes.h	/^inline Lit operator ~ (Lit p) { Lit q; q.x = p.x ^ 1; return q; }$/;"	f
optimize	cir/cirGate.cpp	/^CirGate::optimize() {$/;"	f	class:CirGate
optimize	cir/cirOpt.cpp	/^CirMgr::optimize()$/;"	f	class:CirMgr
order	sat/Solver.h	/^    VarOrder            order;            \/\/ Keeps track of the decision variable order.$/;"	m	class:Solver
order	sat/test/Solver.h	/^    VarOrder            order;            \/\/ Keeps track of the decision variable order.$/;"	m	class:Solver
own_fd	sat/File.h	/^    bool        own_fd;     \/\/ Do we own the file descriptor? If so, will close file in destructor.$/;"	m	class:File
own_fd	sat/test/File.h	/^    bool        own_fd;     \/\/ Do we own the file descriptor? If so, will close file in destructor.$/;"	m	class:File
parent	sat/Heap.h	/^static inline int parent(int i) { return i >> 1; }$/;"	f
parent	sat/test/Heap.h	/^static inline int parent(int i) { return i >> 1; }$/;"	f
parseError	cir/cirMgr.cpp	/^parseError(CirParseError err)$/;"	f	file:
percolateDown	sat/Heap.h	/^    inline void percolateDown(int i)$/;"	f	class:Heap
percolateDown	sat/test/Heap.h	/^    inline void percolateDown(int i)$/;"	f	class:Heap
percolateUp	sat/Heap.h	/^    inline void percolateUp(int i)$/;"	f	class:Heap
percolateUp	sat/test/Heap.h	/^    inline void percolateUp(int i)$/;"	f	class:Heap
pop	sat/Global.h	/^    void     pop    (void)             { sz--, data[sz].~T(); }$/;"	f	class:vec
pop	sat/test/Global.h	/^    void     pop    (void)             { sz--, data[sz].~T(); }$/;"	f	class:vec
pos	sat/File.h	/^    int         pos;        \/\/ Current position in buffer$/;"	m	class:File
pos	sat/test/File.h	/^    int         pos;        \/\/ Current position in buffer$/;"	m	class:File
postorder	cir/cirMgr.cpp	/^CirMgr::postorder(CirGate* gate) const$/;"	f	class:CirMgr
printFECPairs	cir/cirMgr.cpp	/^CirMgr::printFECPairs()$/;"	f	class:CirMgr
printFECs	cir/cirGate.cpp	/^CirGate::printFECs() const$/;"	f	class:CirGate
printFECs	cir/cirMgr.cpp	/^FecGrp::printFECs(unsigned t) {$/;"	f	class:FecGrp
printFloatGates	cir/cirMgr.cpp	/^CirMgr::printFloatGates() const$/;"	f	class:CirMgr
printGate	cir/cirGate.cpp	/^CirGate::printGate(bool isNeg) const$/;"	f	class:CirGate
printNetlist	cir/cirMgr.cpp	/^CirMgr::printNetlist() const$/;"	f	class:CirMgr
printPIs	cir/cirMgr.cpp	/^CirMgr::printPIs() const$/;"	f	class:CirMgr
printPOs	cir/cirMgr.cpp	/^CirMgr::printPOs() const$/;"	f	class:CirMgr
printPrompt	cmd/cmdParser.h	/^   void printPrompt() const { cout << _prompt; }$/;"	f	class:CmdParser
printStats	sat/Solver.cpp	/^void Solver::printStats()$/;"	f	class:Solver
printStats	sat/sat.h	/^      void printStats() const { const_cast<Solver*>(_solver)->printStats(); }$/;"	f	class:SatSolver
printStats	sat/test/Solver.cpp	/^void Solver::printStats()$/;"	f	class:Solver
printStats	sat/test/sat.h	/^      void printStats() const { const_cast<Solver*>(_solver)->printStats(); }$/;"	f	class:SatSolver
printSummary	cir/cirMgr.cpp	/^CirMgr::printSummary() const$/;"	f	class:CirMgr
progressEstimate	sat/Solver.cpp	/^double Solver::progressEstimate()$/;"	f	class:Solver
progressEstimate	sat/test/Solver.cpp	/^double Solver::progressEstimate()$/;"	f	class:Solver
progress_estimate	sat/Solver.h	/^    double      progress_estimate;  \/\/ Set by 'search()'.$/;"	m	class:Solver
progress_estimate	sat/test/Solver.h	/^    double      progress_estimate;  \/\/ Set by 'search()'.$/;"	m	class:Solver
proof	sat/Solver.h	/^    Proof*          proof;              \/\/ Set this directly after constructing 'Solver' to enable proof logging. Initialized to NULL.$/;"	m	class:Solver
proof	sat/test/Solver.h	/^    Proof*          proof;              \/\/ Set this directly after constructing 'Solver' to enable proof logging. Initialized to NULL.$/;"	m	class:Solver
propagate	sat/Solver.cpp	/^Clause* Solver::propagate()$/;"	f	class:Solver
propagate	sat/test/Solver.cpp	/^Clause* Solver::propagate()$/;"	f	class:Solver
propagate_tmpbin	sat/Solver.h	/^    Clause*             propagate_tmpbin;$/;"	m	class:Solver
propagate_tmpbin	sat/test/Solver.h	/^    Clause*             propagate_tmpbin;$/;"	m	class:Solver
propagations	sat/Solver.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
propagations	sat/test/Solver.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
push	sat/Global.h	/^    void     push  (const T& elem)     { if (sz == cap) grow(sz+1); new (&data[sz]) T(elem); sz++; }$/;"	f	class:vec
push	sat/Global.h	/^    void     push  (void)              { if (sz == cap) grow(sz+1); new (&data[sz]) T()    ; sz++; }$/;"	f	class:vec
push	sat/test/Global.h	/^    void     push  (const T& elem)     { if (sz == cap) grow(sz+1); new (&data[sz]) T(elem); sz++; }$/;"	f	class:vec
push	sat/test/Global.h	/^    void     push  (void)              { if (sz == cap) grow(sz+1); new (&data[sz]) T()    ; sz++; }$/;"	f	class:vec
putChar	sat/File.h	/^    int putChar(int chr) {$/;"	f	class:File
putChar	sat/test/File.h	/^    int putChar(int chr) {$/;"	f	class:File
putCharQ	sat/File.h	/^    int putCharQ(int chr) {         \/\/ Quick version with minimal overhead -- don't call this in the wrong mode!$/;"	f	class:File
putCharQ	sat/test/File.h	/^    int putCharQ(int chr) {         \/\/ Quick version with minimal overhead -- don't call this in the wrong mode!$/;"	f	class:File
putInt	sat/File.h	/^static inline void   putInt  (File& out, int64 val) { putUInt(out, encode64(val)); }$/;"	f
putInt	sat/test/File.h	/^static inline void   putInt  (File& out, int64 val) { putUInt(out, encode64(val)); }$/;"	f
putUInt	sat/File.cpp	/^void putUInt(File& out, uint64 val)$/;"	f
putUInt	sat/test/File.cpp	/^void putUInt(File& out, uint64 val)$/;"	f
qhead	sat/Solver.h	/^    int                 qhead;            \/\/ Head of queue (as index into the trail -- no more explicit propagation queue in MiniSat).$/;"	m	class:Solver
qhead	sat/test/Solver.h	/^    int                 qhead;            \/\/ Head of queue (as index into the trail -- no more explicit propagation queue in MiniSat).$/;"	m	class:Solver
query	util/myHashMap.h	/^   bool query(const HashKey& k, HashData& d) const {$/;"	f	class:HashMap
query	util/myHashSet.h	/^   bool query(Data& d) const {$/;"	f	class:HashSet
randomSim	cir/cirSim.cpp	/^CirMgr::randomSim()$/;"	f	class:CirMgr
random_seed	sat/VarOrder.h	/^    double              random_seed; \/\/ For the internal random number generator$/;"	m	class:VarOrder
random_seed	sat/test/VarOrder.h	/^    double              random_seed; \/\/ For the internal random number generator$/;"	m	class:VarOrder
random_var_freq	sat/Solver.h	/^    double  var_decay, clause_decay, random_var_freq;    \/\/ (reasonable values are: 0.95, 0.999, 0.02)    $/;"	m	struct:SearchParams
random_var_freq	sat/test/Solver.h	/^    double  var_decay, clause_decay, random_var_freq;    \/\/ (reasonable values are: 0.95, 0.999, 0.02)    $/;"	m	struct:SearchParams
reSim	cir/cirFraig.cpp	/^CirMgr::reSim(const SatSolver& s)$/;"	f	class:CirMgr
read	util/myHashMap.h	/^   bool read(const CacheKey& k, CacheData& d) const {$/;"	f	class:Cache
readAIG	cir/cirMgr.cpp	/^CirMgr::readAIG(ifstream& fin){$/;"	f	class:CirMgr
readCircuit	cir/cirMgr.cpp	/^CirMgr::readCircuit(const string& fileName)$/;"	f	class:CirMgr
readFirstLine	cir/cirMgr.cpp	/^CirMgr::readFirstLine(ifstream& fin){$/;"	f	class:CirMgr
readNoError	cir/cirMgr.cpp	/^CirMgr::readNoError(ifstream& fin){$/;"	f	class:CirMgr
readPI	cir/cirMgr.cpp	/^CirMgr::readPI(ifstream& fin){$/;"	f	class:CirMgr
readPO	cir/cirMgr.cpp	/^CirMgr::readPO(ifstream& fin){$/;"	f	class:CirMgr
readSymbol	cir/cirMgr.cpp	/^CirMgr::readSymbol(ifstream& fin){$/;"	f	class:CirMgr
reason	sat/Solver.h	/^    vec<Clause*>        reason;           \/\/ 'reason[var]' is the clause that implied the variables current value, or 'NULL' if none.$/;"	m	class:Solver
reason	sat/test/Solver.h	/^    vec<Clause*>        reason;           \/\/ 'reason[var]' is the clause that implied the variables current value, or 'NULL' if none.$/;"	m	class:Solver
reduceDB	sat/Solver.cpp	/^void Solver::reduceDB()$/;"	f	class:Solver
reduceDB	sat/test/Solver.cpp	/^void Solver::reduceDB()$/;"	f	class:Solver
reduceDB_lt	sat/Solver.cpp	/^struct reduceDB_lt { bool operator () (Clause* x, Clause* y) { return x->size() > 2 && (y->size() == 2 || x->activity() < y->activity()); } };$/;"	s	file:
reduceDB_lt	sat/test/Solver.cpp	/^struct reduceDB_lt { bool operator () (Clause* x, Clause* y) { return x->size() > 2 && (y->size() == 2 || x->activity() < y->activity()); } };$/;"	s	file:
release	sat/Global.h	/^    T*       release  (void)           { T* ret = data; data = NULL; sz = 0; cap = 0; return ret; }$/;"	f	class:vec
release	sat/test/Global.h	/^    T*       release  (void)           { T* ret = data; data = NULL; sz = 0; cap = 0; return ret; }$/;"	f	class:vec
releaseDescriptor	sat/File.h	/^    int releaseDescriptor(void) {   \/\/ Don't run UNIX function 'close()' on descriptor in 'File's 'close()'.$/;"	f	class:File
releaseDescriptor	sat/test/File.h	/^    int releaseDescriptor(void) {   \/\/ Don't run UNIX function 'close()' on descriptor in 'File's 'close()'.$/;"	f	class:File
remove	sat/Solver.cpp	/^void Solver::remove(Clause* c, bool just_dealloc)$/;"	f	class:Solver
remove	sat/test/Solver.cpp	/^void Solver::remove(Clause* c, bool just_dealloc)$/;"	f	class:Solver
remove	util/myHashMap.h	/^   bool remove(const HashKey& k) {$/;"	f	class:HashMap
remove	util/myHashSet.h	/^   bool remove(const Data& d) {$/;"	f	class:HashSet
removeData	util/util.h	/^void removeData(T& l, const D& d)$/;"	f
removeNotInDFSfromFECs	cir/cirMgr.cpp	/^CirMgr::removeNotInDFSfromFECs()$/;"	f	class:CirMgr
removeWatch	sat/Solver.cpp	/^void removeWatch(vec<Clause*>& ws, Clause* elem)$/;"	f
removeWatch	sat/test/Solver.cpp	/^void removeWatch(vec<Clause*>& ws, Clause* elem)$/;"	f
report	util/myUsage.h	/^   void report(bool repTime, bool repMem) {$/;"	f	class:MyUsage
reportFanin	cir/cirGate.cpp	/^CirGate::reportFanin(int level) const$/;"	f	class:CirGate
reportFanout	cir/cirGate.cpp	/^CirGate::reportFanout(int level) const$/;"	f	class:CirGate
reportGate	cir/cirGate.cpp	/^CirGate::reportGate() const$/;"	f	class:CirGate
reportResult	sat/test/satTest.cpp	/^void reportResult(const SatSolver& solver, bool result)$/;"	f
reportf	sat/Solver.h	/^#define reportf(/;"	d
reportf	sat/test/Solver.h	/^#define reportf(/;"	d
reset	sat/sat.h	/^      void reset() {$/;"	f	class:SatSolver
reset	sat/test/sat.h	/^      void reset() {$/;"	f	class:SatSolver
reset	util/myHashMap.h	/^   void reset() {  _size = 0; if (_cache) { delete [] _cache; _cache = 0; } }$/;"	f	class:Cache
reset	util/myHashMap.h	/^   void reset() {$/;"	f	class:HashMap
reset	util/myHashSet.h	/^   void reset() {$/;"	f	class:HashSet
reset	util/myUsage.h	/^   void reset() {$/;"	f	class:MyUsage
resetBufAndPrintPrompt	cmd/cmdParser.h	/^   void resetBufAndPrintPrompt() {$/;"	f	class:CmdParser
resetFEC	cir/cirSim.cpp	/^CirMgr::resetFEC()$/;"	f	class:CirMgr
reset_keypress	util/myGetChar.cpp	/^static void reset_keypress(void)$/;"	f	file:
resolve	sat/Proof.cpp	/^void Proof::resolve(ClauseId next, Lit x)$/;"	f	class:Proof
resolve	sat/test/Proof.cpp	/^void Proof::resolve(ClauseId next, Lit x)$/;"	f	class:Proof
right	sat/Heap.h	/^static inline int right (int i) { return i+i + 1; }$/;"	f
right	sat/test/Heap.h	/^static inline int right (int i) { return i+i + 1; }$/;"	f
rnGenSize_t	cir/cirMgr.h	/^   size_t rnGenSize_t() { return (size_t(rnGen(INT_MAX)) << 32) + rnGen(INT_MAX); }$/;"	f	class:CirMgr
root_level	sat/Solver.h	/^    int                 root_level;       \/\/ Level of first proper decision.$/;"	m	class:Solver
root_level	sat/test/Solver.h	/^    int                 root_level;       \/\/ Level of first proper decision.$/;"	m	class:Solver
save	sat/Proof.cpp	/^bool Proof::save(cchar* filename)$/;"	f	class:Proof
save	sat/test/Proof.cpp	/^bool Proof::save(cchar* filename)$/;"	f	class:Proof
search	sat/Solver.cpp	/^lbool Solver::search(int nof_conflicts, int nof_learnts, const SearchParams& params)$/;"	f	class:Solver
search	sat/test/Solver.cpp	/^lbool Solver::search(int nof_conflicts, int nof_learnts, const SearchParams& params)$/;"	f	class:Solver
seek	sat/File.cpp	/^void File::seek(int64 file_pos, int whence)$/;"	f	class:File
seek	sat/test/File.cpp	/^void File::seek(int64 file_pos, int whence)$/;"	f	class:File
select	sat/VarOrder.h	/^Var VarOrder::select(double random_var_freq)$/;"	f	class:VarOrder
select	sat/test/VarOrder.h	/^Var VarOrder::select(double random_var_freq)$/;"	f	class:VarOrder
selectionSort	sat/Sort.h	/^template <class T> static inline void selectionSort(T* array, int size) {$/;"	f
selectionSort	sat/Sort.h	/^void selectionSort(T* array, int size, LessThan lt)$/;"	f
selectionSort	sat/test/Sort.h	/^template <class T> static inline void selectionSort(T* array, int size) {$/;"	f
selectionSort	sat/test/Sort.h	/^void selectionSort(T* array, int size, LessThan lt)$/;"	f
setBase	cir/cirMgr.cpp	/^FecGrp::setBase() {$/;"	f	class:FecGrp
setBounds	sat/Heap.h	/^    void setBounds (int size) { assert(size >= 0); indices.growTo(size,0); }$/;"	f	class:Heap
setBounds	sat/test/Heap.h	/^    void setBounds (int size) { assert(size >= 0); indices.growTo(size,0); }$/;"	f	class:Heap
setDFS	cir/cirMgr.cpp	/^CirMgr::setDFS(){$/;"	f	class:CirMgr
setFECs	cir/cirMgr.cpp	/^FecGrp::setFECs(FecHash& h) {$/;"	f	class:FecGrp
setFU	cir/cirMgr.cpp	/^CirMgr::setFU(){$/;"	f	class:CirMgr
setFecFriends	cir/cirSim.cpp	/^CirMgr::setFecFriends()$/;"	f	class:CirMgr
setGlobalRef	cir/cirGate.cpp	/^void CirGate::setGlobalRef() { ++_globalRef; }$/;"	f	class:CirGate
setMemUsage	util/myUsage.h	/^   void setMemUsage() { _currentMem = checkMem() - _initMem; }$/;"	f	class:MyUsage
setMode	sat/File.h	/^    void setMode(FileMode m) {$/;"	f	class:File
setMode	sat/test/File.h	/^    void setMode(FileMode m) {$/;"	f	class:File
setOptCmd	cmd/cmdParser.h	/^   void setOptCmd(const string& str) { _optCmd = str; }$/;"	f	class:CmdExec
setPos	cir/cirGate.h	/^   void setPos(unsigned p) { _pos = p; }$/;"	f	class:CirGate
setRef	cir/cirGate.cpp	/^void CirGate::setRef() const { _ref = _globalRef; }$/;"	f	class:CirGate
setSimLog	cir/cirMgr.h	/^   void setSimLog(ofstream *logFile) { _simLog = logFile; }$/;"	f	class:CirMgr
setSimVal	cir/cirGate.h	/^   void setSimVal(size_t sv) { _val = SimValue(sv); }$/;"	f	class:CirGate
setSymbol	cir/cirGate.h	/^   virtual void setSymbol(string s) { _sym = s; }$/;"	f	class:CirPIGate
setSymbol	cir/cirGate.h	/^   virtual void setSymbol(string s) { _sym = s; }$/;"	f	class:CirPOGate
setSymbol	cir/cirGate.h	/^   virtual void setSymbol(string s) {}$/;"	f	class:CirGate
setTimeUsage	util/myUsage.h	/^   void setTimeUsage() {$/;"	f	class:MyUsage
setVar	cir/cirGate.h	/^   virtual void setVar(const Var& c) {}$/;"	f	class:CirGate
setVar	cir/cirGate.h	/^   virtual void setVar(const Var& v) { _var = v; }$/;"	f	class:CirAIGGate
setVar	cir/cirGate.h	/^   virtual void setVar(const Var& v) { _var = v; }$/;"	f	class:CirCONSTGate
setVar	cir/cirGate.h	/^   virtual void setVar(const Var& v) { _var = v; }$/;"	f	class:CirPIGate
setVar	cir/cirGate.h	/^   virtual void setVar(const Var& v) { _var = v; }$/;"	f	class:CirUNDEFGate
setVar	sat/test/satTest.cpp	/^   void setVar(const Var& v) { _var = v; }$/;"	f	class:Gate
set_keypress	util/myGetChar.cpp	/^static void set_keypress(void)$/;"	f	file:
shrink	sat/Global.h	/^    void     shrink (int nelems)       { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }$/;"	f	class:vec
shrink	sat/test/Global.h	/^    void     shrink (int nelems)       { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }$/;"	f	class:vec
sign	sat/SolverTypes.h	/^inline bool sign  (Lit p) { return p.x & 1; }$/;"	f
sign	sat/test/SolverTypes.h	/^inline bool sign  (Lit p) { return p.x & 1; }$/;"	f
simCount	cir/cirSim.cpp	/^static size_t simCount;$/;"	v	file:
simLen	cir/cirSim.cpp	/^static size_t simLen;$/;"	v	file:
simpDB_assigns	sat/Solver.h	/^    int                 simpDB_assigns;   \/\/ Number of top-level assignments since last execution of 'simplifyDB()'.$/;"	m	class:Solver
simpDB_assigns	sat/test/Solver.h	/^    int                 simpDB_assigns;   \/\/ Number of top-level assignments since last execution of 'simplifyDB()'.$/;"	m	class:Solver
simpDB_props	sat/Solver.h	/^    int64               simpDB_props;     \/\/ Remaining number of propagations that must be made before next execution of 'simplifyDB()'.$/;"	m	class:Solver
simpDB_props	sat/test/Solver.h	/^    int64               simpDB_props;     \/\/ Remaining number of propagations that must be made before next execution of 'simplifyDB()'.$/;"	m	class:Solver
simplify	sat/Solver.cpp	/^bool Solver::simplify(Clause* c) const$/;"	f	class:Solver
simplify	sat/test/Solver.cpp	/^bool Solver::simplify(Clause* c) const$/;"	f	class:Solver
simplifyDB	sat/Solver.cpp	/^void Solver::simplifyDB()$/;"	f	class:Solver
simplifyDB	sat/test/Solver.cpp	/^void Solver::simplifyDB()$/;"	f	class:Solver
simulate	cir/cirGate.h	/^   virtual void simulate() {$/;"	f	class:CirAIGGate
simulate	cir/cirGate.h	/^   virtual void simulate() {$/;"	f	class:CirPOGate
simulate	cir/cirGate.h	/^   virtual void simulate() {}$/;"	f	class:CirGate
simulate	cir/cirSim.cpp	/^CirMgr::simulate(bool inputSet)$/;"	f	class:CirMgr
simulateCircuit	cir/cirSim.cpp	/^CirMgr::simulateCircuit(bool inputSet)$/;"	f	class:CirMgr
size	cir/cirMgr.h	/^   size_t size() const { return _data.size(); }$/;"	f	class:FecGrp
size	sat/File.h	/^    int         size;       \/\/ Size of buffer (at end of file, less than 'File_BufSize').$/;"	m	class:File
size	sat/Global.h	/^    int      size   (void) const       { return sz; }$/;"	f	class:vec
size	sat/SolverTypes.h	/^    int       size        ()      const { return size_learnt >> 1; }$/;"	f	class:Clause
size	sat/test/File.h	/^    int         size;       \/\/ Size of buffer (at end of file, less than 'File_BufSize').$/;"	m	class:File
size	sat/test/Global.h	/^    int      size   (void) const       { return sz; }$/;"	f	class:vec
size	sat/test/SolverTypes.h	/^    int       size        ()      const { return size_learnt >> 1; }$/;"	f	class:Clause
size	util/myHashMap.h	/^   size_t size() const { return _size; }$/;"	f	class:Cache
size	util/myHashMap.h	/^   size_t size() const {$/;"	f	class:HashMap
size	util/myHashSet.h	/^   size_t size() const {$/;"	f	class:HashSet
size_learnt	sat/SolverTypes.h	/^    uint    size_learnt;$/;"	m	class:Clause
size_learnt	sat/test/SolverTypes.h	/^    uint    size_learnt;$/;"	m	class:Clause
snd	util/myHashMap.h	/^#define snd /;"	d
solve	sat/Solver.cpp	/^bool Solver::solve(const vec<Lit>& assumps)$/;"	f	class:Solver
solve	sat/Solver.h	/^    bool    solve() { vec<Lit> tmp; return solve(tmp); }$/;"	f	class:Solver
solve	sat/sat.h	/^      bool solve() { _solver->solve(); return _solver->okay(); }$/;"	f	class:SatSolver
solve	sat/test/Solver.cpp	/^bool Solver::solve(const vec<Lit>& assumps)$/;"	f	class:Solver
solve	sat/test/Solver.h	/^    bool    solve() { vec<Lit> tmp; return solve(tmp); }$/;"	f	class:Solver
solve	sat/test/sat.h	/^      bool solve() { _solver->solve(); return _solver->okay(); }$/;"	f	class:SatSolver
sort	cir/cirMgr.h	/^   void sort() { ::sort(_data.begin(), _data.end()); }$/;"	f	class:FecGrp
sort	sat/Sort.h	/^template <class T, class LessThan> void sort(T* array, int size, LessThan lt) {$/;"	f
sort	sat/Sort.h	/^template <class T, class LessThan> void sort(vec<T>& v, LessThan lt) {$/;"	f
sort	sat/Sort.h	/^template <class T> static inline void sort(T* array, int size) {$/;"	f
sort	sat/Sort.h	/^template <class T> void sort(vec<T>& v) {$/;"	f
sort	sat/Sort.h	/^void sort(T* array, int size, LessThan lt, double& seed)$/;"	f
sort	sat/test/Sort.h	/^template <class T, class LessThan> void sort(T* array, int size, LessThan lt) {$/;"	f
sort	sat/test/Sort.h	/^template <class T, class LessThan> void sort(vec<T>& v, LessThan lt) {$/;"	f
sort	sat/test/Sort.h	/^template <class T> static inline void sort(T* array, int size) {$/;"	f
sort	sat/test/Sort.h	/^template <class T> void sort(vec<T>& v) {$/;"	f
sort	sat/test/Sort.h	/^void sort(T* array, int size, LessThan lt, double& seed)$/;"	f
sortUnique	sat/Sort.h	/^template <class T, class LessThan> void sortUnique(vec<T>& v, LessThan lt) {$/;"	f
sortUnique	sat/Sort.h	/^template <class T> static inline void sortUnique(T* array, int& size) {$/;"	f
sortUnique	sat/Sort.h	/^template <class T> void sortUnique(vec<T>& v) {$/;"	f
sortUnique	sat/Sort.h	/^void sortUnique(T* array, int& size, LessThan lt)$/;"	f
sortUnique	sat/test/Sort.h	/^template <class T, class LessThan> void sortUnique(vec<T>& v, LessThan lt) {$/;"	f
sortUnique	sat/test/Sort.h	/^template <class T> static inline void sortUnique(T* array, int& size) {$/;"	f
sortUnique	sat/test/Sort.h	/^template <class T> void sortUnique(vec<T>& v) {$/;"	f
sortUnique	sat/test/Sort.h	/^void sortUnique(T* array, int& size, LessThan lt)$/;"	f
starts	sat/Solver.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
starts	sat/test/Solver.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
stats	sat/Solver.h	/^    SolverStats     stats;$/;"	m	class:Solver
stats	sat/test/Solver.h	/^    SolverStats     stats;$/;"	m	class:Solver
stored_settings	util/myGetChar.cpp	/^static struct termios stored_settings;$/;"	v	typeref:struct:termios	file:
strash	cir/cirFraig.cpp	/^CirMgr::strash()$/;"	f	class:CirMgr
strashMerge	cir/cirGate.cpp	/^CirGate::strashMerge(CirGate* gate)$/;"	f	class:CirGate
sweep	cir/cirGate.cpp	/^CirGate::sweep() {$/;"	f	class:CirGate
sweep	cir/cirOpt.cpp	/^CirMgr::sweep()$/;"	f	class:CirMgr
sz	sat/Global.h	/^    int sz;$/;"	m	class:vec
sz	sat/test/Global.h	/^    int sz;$/;"	m	class:vec
taTestOnly	cmd/cmdParser.h	/^   void taTestOnly() {}$/;"	f	class:CmdParser
tell	sat/File.cpp	/^int64 File::tell(void)$/;"	f	class:File
tell	sat/test/File.cpp	/^int64 File::tell(void)$/;"	f	class:File
temp_files	sat/Proof.cpp	/^static TempFiles temp_files;       \/\/ (should be singleton)$/;"	v	file:
temp_files	sat/test/Proof.cpp	/^static TempFiles temp_files;       \/\/ (should be singleton)$/;"	v	file:
toDimacs	sat/SolverTypes.h	/^inline int toDimacs(Lit p) { return sign(p) ? -var(p) - 1 : var(p) + 1; }$/;"	f
toDimacs	sat/test/SolverTypes.h	/^inline int toDimacs(Lit p) { return sign(p) ? -var(p) - 1 : var(p) + 1; }$/;"	f
toInt	sat/Global.h	/^    int toInt(void) const { return value; }$/;"	f	class:lbool
toInt	sat/Global.h	/^inline int   toInt  (lbool l) { return l.toInt(); }$/;"	f
toInt	sat/test/Global.h	/^    int toInt(void) const { return value; }$/;"	f	class:lbool
toInt	sat/test/Global.h	/^inline int   toInt  (lbool l) { return l.toInt(); }$/;"	f
toLbool	sat/Global.h	/^inline lbool toLbool(int   v) { return lbool(v);  }$/;"	f
toLbool	sat/test/Global.h	/^inline lbool toLbool(int   v) { return lbool(v);  }$/;"	f
toLit	sat/SolverTypes.h	/^inline Lit  toLit (int i) { Lit p; p.x = i; return p; }  \/\/ Inverse of 'index()'.$/;"	f
toLit	sat/test/SolverTypes.h	/^inline Lit  toLit (int i) { Lit p; p.x = i; return p; }  \/\/ Inverse of 'index()'.$/;"	f
tot_literals	sat/Solver.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
tot_literals	sat/test/Solver.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
trail	sat/Solver.h	/^    vec<Lit>            trail;            \/\/ Assignment stack; stores all assigments made in the order they were made.$/;"	m	class:Solver
trail	sat/test/Solver.h	/^    vec<Lit>            trail;            \/\/ Assignment stack; stores all assigments made in the order they were made.$/;"	m	class:Solver
trail_lim	sat/Solver.h	/^    vec<int>            trail_lim;        \/\/ Separator indices for different decision levels in 'trail[]'.$/;"	m	class:Solver
trail_lim	sat/test/Solver.h	/^    vec<int>            trail_lim;        \/\/ Separator indices for different decision levels in 'trail[]'.$/;"	m	class:Solver
trail_pos	sat/Solver.cpp	/^    const vec<int>& trail_pos;$/;"	m	class:lastToFirst_lt	file:
trail_pos	sat/Solver.h	/^    vec<int>            trail_pos;        \/\/ 'trail_pos[var]' is the variable's position in 'trail[]'. This supersedes 'level[]' in some sense, and 'level[]' will probably be removed in future releases.$/;"	m	class:Solver
trail_pos	sat/test/Solver.cpp	/^    const vec<int>& trail_pos;$/;"	m	class:lastToFirst_lt	file:
trail_pos	sat/test/Solver.h	/^    vec<int>            trail_pos;        \/\/ 'trail_pos[var]' is the variable's position in 'trail[]'. This supersedes 'level[]' in some sense, and 'level[]' will probably be removed in future releases.$/;"	m	class:Solver
trav	sat/Proof.h	/^    ProofTraverser* trav;$/;"	m	class:Proof
trav	sat/test/Proof.h	/^    ProofTraverser* trav;$/;"	m	class:Proof
traverse	sat/Proof.cpp	/^void Proof::traverse(ProofTraverser& trav, ClauseId goal)$/;"	f	class:Proof
traverse	sat/test/Proof.cpp	/^void Proof::traverse(ProofTraverser& trav, ClauseId goal)$/;"	f	class:Proof
uchar	sat/Global.h	/^typedef unsigned char uchar;$/;"	t
uchar	sat/test/Global.h	/^typedef unsigned char uchar;$/;"	t
uint	sat/Global.h	/^typedef unsigned int uint;$/;"	t
uint	sat/test/Global.h	/^typedef unsigned int uint;$/;"	t
uint64	sat/Global.h	/^typedef UINT64             uint64;$/;"	t
uint64	sat/Global.h	/^typedef unsigned long long uint64;$/;"	t
uint64	sat/test/Global.h	/^typedef UINT64             uint64;$/;"	t
uint64	sat/test/Global.h	/^typedef unsigned long long uint64;$/;"	t
uintp	sat/Global.h	/^typedef UINT_PTR           uintp;$/;"	t
uintp	sat/Global.h	/^typedef unsigned __PTRDIFF_TYPE__ uintp;$/;"	t
uintp	sat/test/Global.h	/^typedef UINT_PTR           uintp;$/;"	t
uintp	sat/test/Global.h	/^typedef unsigned __PTRDIFF_TYPE__ uintp;$/;"	t
undo	sat/VarOrder.h	/^void VarOrder::undo(Var x)$/;"	f	class:VarOrder
undo	sat/test/VarOrder.h	/^void VarOrder::undo(Var x)$/;"	f	class:VarOrder
unit_id	sat/Solver.h	/^    vec<ClauseId>       unit_id;          \/\/ 'unit_id[var]' is the clause ID for the unit literal 'var' or '~var' (if set at toplevel).$/;"	m	class:Solver
unit_id	sat/test/Solver.h	/^    vec<ClauseId>       unit_id;          \/\/ 'unit_id[var]' is the clause ID for the unit literal 'var' or '~var' (if set at toplevel).$/;"	m	class:Solver
unsign	sat/SolverTypes.h	/^inline Lit  unsign(Lit p) { Lit q; q.x = p.x & ~1; return q; }$/;"	f
unsign	sat/test/SolverTypes.h	/^inline Lit  unsign(Lit p) { Lit q; q.x = p.x & ~1; return q; }$/;"	f
update	sat/VarOrder.h	/^void VarOrder::update(Var x)$/;"	f	class:VarOrder
update	sat/test/VarOrder.h	/^void VarOrder::update(Var x)$/;"	f	class:VarOrder
update	util/myHashMap.h	/^   bool update(const HashKey& k, HashData& d) {$/;"	f	class:HashMap
update	util/myHashSet.h	/^   bool update(const Data& d) {$/;"	f	class:HashSet
usage	cir/cirCmd.cpp	/^CirFraigCmd::usage(ostream& os) const$/;"	f	class:CirFraigCmd
usage	cir/cirCmd.cpp	/^CirGateCmd::usage(ostream& os) const$/;"	f	class:CirGateCmd
usage	cir/cirCmd.cpp	/^CirOptCmd::usage(ostream& os) const$/;"	f	class:CirOptCmd
usage	cir/cirCmd.cpp	/^CirPrintCmd::usage(ostream& os) const$/;"	f	class:CirPrintCmd
usage	cir/cirCmd.cpp	/^CirReadCmd::usage(ostream& os) const$/;"	f	class:CirReadCmd
usage	cir/cirCmd.cpp	/^CirSimCmd::usage(ostream& os) const$/;"	f	class:CirSimCmd
usage	cir/cirCmd.cpp	/^CirStrashCmd::usage(ostream& os) const$/;"	f	class:CirStrashCmd
usage	cir/cirCmd.cpp	/^CirSweepCmd::usage(ostream& os) const$/;"	f	class:CirSweepCmd
usage	cir/cirCmd.cpp	/^CirWriteCmd::usage(ostream& os) const$/;"	f	class:CirWriteCmd
usage	main/main.cpp	/^usage()$/;"	f	file:
value	sat/Global.h	/^    int     value;$/;"	m	class:lbool
value	sat/Solver.h	/^    lbool   value(Lit p) const { return sign(p) ? ~toLbool(assigns[var(p)]) : toLbool(assigns[var(p)]); }$/;"	f	class:Solver
value	sat/Solver.h	/^    lbool   value(Var x) const { return toLbool(assigns[x]); }$/;"	f	class:Solver
value	sat/test/Global.h	/^    int     value;$/;"	m	class:lbool
value	sat/test/Solver.h	/^    lbool   value(Lit p) const { return sign(p) ? ~toLbool(assigns[var(p)]) : toLbool(assigns[var(p)]); }$/;"	f	class:Solver
value	sat/test/Solver.h	/^    lbool   value(Var x) const { return toLbool(assigns[x]); }$/;"	f	class:Solver
var	sat/SolverTypes.h	/^inline int  var   (Lit p) { return p.x >> 1; }$/;"	f
var	sat/test/SolverTypes.h	/^inline int  var   (Lit p) { return p.x >> 1; }$/;"	f
varBumpActivity	sat/Solver.h	/^    void     varBumpActivity(Lit p) {$/;"	f	class:Solver
varBumpActivity	sat/test/Solver.h	/^    void     varBumpActivity(Lit p) {$/;"	f	class:Solver
varDecayActivity	sat/Solver.h	/^    void     varDecayActivity  () { if (var_decay >= 0) var_inc *= var_decay; }$/;"	f	class:Solver
varDecayActivity	sat/test/Solver.h	/^    void     varDecayActivity  () { if (var_decay >= 0) var_inc *= var_decay; }$/;"	f	class:Solver
varRescaleActivity	sat/Solver.cpp	/^void Solver::varRescaleActivity()$/;"	f	class:Solver
varRescaleActivity	sat/test/Solver.cpp	/^void Solver::varRescaleActivity()$/;"	f	class:Solver
var_Undef	sat/SolverTypes.h	/^#define var_Undef /;"	d
var_Undef	sat/test/SolverTypes.h	/^#define var_Undef /;"	d
var_decay	sat/Solver.h	/^    double              var_decay;        \/\/ INVERSE decay factor for variable activity: stores 1\/decay. Use negative value for static variable order.$/;"	m	class:Solver
var_decay	sat/Solver.h	/^    double  var_decay, clause_decay, random_var_freq;    \/\/ (reasonable values are: 0.95, 0.999, 0.02)    $/;"	m	struct:SearchParams
var_decay	sat/test/Solver.h	/^    double              var_decay;        \/\/ INVERSE decay factor for variable activity: stores 1\/decay. Use negative value for static variable order.$/;"	m	class:Solver
var_decay	sat/test/Solver.h	/^    double  var_decay, clause_decay, random_var_freq;    \/\/ (reasonable values are: 0.95, 0.999, 0.02)    $/;"	m	struct:SearchParams
var_inc	sat/Solver.h	/^    double              var_inc;          \/\/ Amount to bump next variable with.$/;"	m	class:Solver
var_inc	sat/test/Solver.h	/^    double              var_inc;          \/\/ Amount to bump next variable with.$/;"	m	class:Solver
vec	sat/Global.h	/^             vec        (vec<T>& other) { TEMPLATE_FAIL; }$/;"	f	class:vec
vec	sat/Global.h	/^    vec(T* array, int size)     : data(array), sz(size), cap(size) { }      \/\/ (takes ownership of array -- will be deallocated with 'xfree()')$/;"	f	class:vec
vec	sat/Global.h	/^    vec(int size)               : data(NULL) , sz(0)   , cap(0)    { growTo(size); }$/;"	f	class:vec
vec	sat/Global.h	/^    vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }$/;"	f	class:vec
vec	sat/Global.h	/^    vec(void)                   : data(NULL) , sz(0)   , cap(0)    { }$/;"	f	class:vec
vec	sat/Global.h	/^class vec {$/;"	c
vec	sat/test/Global.h	/^             vec        (vec<T>& other) { TEMPLATE_FAIL; }$/;"	f	class:vec
vec	sat/test/Global.h	/^    vec(T* array, int size)     : data(array), sz(size), cap(size) { }      \/\/ (takes ownership of array -- will be deallocated with 'xfree()')$/;"	f	class:vec
vec	sat/test/Global.h	/^    vec(int size)               : data(NULL) , sz(0)   , cap(0)    { growTo(size); }$/;"	f	class:vec
vec	sat/test/Global.h	/^    vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }$/;"	f	class:vec
vec	sat/test/Global.h	/^    vec(void)                   : data(NULL) , sz(0)   , cap(0)    { }$/;"	f	class:vec
vec	sat/test/Global.h	/^class vec {$/;"	c
verbosity	sat/Solver.h	/^    int             verbosity;          \/\/ Verbosity level. 0=silent, 1=some progress report, 2=everything$/;"	m	class:Solver
verbosity	sat/test/Solver.h	/^    int             verbosity;          \/\/ Verbosity level. 0=silent, 1=some progress report, 2=everything$/;"	m	class:Solver
watches	sat/Solver.h	/^    vec<vec<Clause*> >  watches;          \/\/ 'watches[lit]' is a list of constraints watching 'lit' (will go there if literal becomes true).$/;"	m	class:Solver
watches	sat/test/Solver.h	/^    vec<vec<Clause*> >  watches;          \/\/ 'watches[lit]' is a list of constraints watching 'lit' (will go there if literal becomes true).$/;"	m	class:Solver
write	util/myHashMap.h	/^   void write(const CacheKey& k, const CacheData& d) {$/;"	f	class:Cache
writeAIG	cir/cirMgr.cpp	/^IdList writeAIG;$/;"	v
writeAag	cir/cirMgr.cpp	/^CirMgr::writeAag(ostream& outfile) const$/;"	f	class:CirMgr
writeDFS	cir/cirMgr.cpp	/^CirMgr::writeDFS(CirGate* g) const$/;"	f	class:CirMgr
writeGate	cir/cirMgr.cpp	/^CirMgr::writeGate(ostream& outfile, CirGate *g) const$/;"	f	class:CirMgr
writeLog	cir/cirSim.cpp	/^CirMgr::writeLog(){$/;"	f	class:CirMgr
x	cir/test.py	/^x = input("input a word")$/;"	v
x	sat/SolverTypes.h	/^    int     x;$/;"	m	class:Lit
x	sat/test/SolverTypes.h	/^    int     x;$/;"	m	class:Lit
xfree	sat/Global.h	/^template<class T> static inline void xfree(T *ptr) {$/;"	f
xfree	sat/test/Global.h	/^template<class T> static inline void xfree(T *ptr) {$/;"	f
xmalloc	sat/Global.h	/^template<class T> static inline T* xmalloc(size_t size) {$/;"	f
xmalloc	sat/test/Global.h	/^template<class T> static inline T* xmalloc(size_t size) {$/;"	f
xrealloc	sat/Global.h	/^template<class T> static inline T* xrealloc(T* ptr, size_t size) {$/;"	f
xrealloc	sat/test/Global.h	/^template<class T> static inline T* xrealloc(T* ptr, size_t size) {$/;"	f
~Cache	util/myHashMap.h	/^   ~Cache() { reset(); }$/;"	f	class:Cache
~CirGate	cir/cirGate.h	/^   virtual ~CirGate() {}$/;"	f	class:CirGate
~CirMgr	cir/cirMgr.cpp	/^CirMgr::~CirMgr(){$/;"	f	class:CirMgr
~CmdExec	cmd/cmdParser.h	/^   virtual ~CmdExec() {}$/;"	f	class:CmdExec
~CmdParser	cmd/cmdParser.h	/^   virtual ~CmdParser() {}$/;"	f	class:CmdParser
~File	sat/File.h	/^   ~File(void) {$/;"	f	class:File
~File	sat/test/File.h	/^   ~File(void) {$/;"	f	class:File
~Gate	sat/test/satTest.cpp	/^   ~Gate() {}$/;"	f	class:Gate
~HashMap	util/myHashMap.h	/^   ~HashMap() { reset(); }$/;"	f	class:HashMap
~HashSet	util/myHashSet.h	/^   ~HashSet() { reset(); }$/;"	f	class:HashSet
~ProofTraverser	sat/Proof.h	/^    virtual ~ProofTraverser(){}$/;"	f	struct:ProofTraverser
~ProofTraverser	sat/test/Proof.h	/^    virtual ~ProofTraverser(){}$/;"	f	struct:ProofTraverser
~SatSolver	sat/sat.h	/^      ~SatSolver() { if (_solver) delete _solver; }$/;"	f	class:SatSolver
~SatSolver	sat/test/sat.h	/^      ~SatSolver() { if (_solver) delete _solver; }$/;"	f	class:SatSolver
~Solver	sat/Solver.h	/^   ~Solver() {$/;"	f	class:Solver
~Solver	sat/test/Solver.h	/^   ~Solver() {$/;"	f	class:Solver
~TempFiles	sat/Proof.cpp	/^   ~TempFiles()$/;"	f	class:TempFiles
~TempFiles	sat/test/Proof.cpp	/^   ~TempFiles()$/;"	f	class:TempFiles
~vec	sat/Global.h	/^   ~vec(void)                                                      { clear(true); }$/;"	f	class:vec
~vec	sat/test/Global.h	/^   ~vec(void)                                                      { clear(true); }$/;"	f	class:vec
